\ifx\allfiles\undefined
\documentclass[12pt, a4paper, oneside, UTF8]{ctexbook}
\def\path{../config}
\input{../config/_config}
\begin{document}
% \input{../config/cover}
\else
\fi
\chapter{计算机组成原理}

\section{选择题}

\subsection{25-王道}
\begin{enumerate}
    \item 冯$\cdot$诺依曼机的基本工作方式是(  ) 
    \begin{choices}[2]
    \task 控制流驱动方式 \task 多指令多数据流方式
    \task 微程序控制器 \task 数据流驱动方式
    \end{choices}
    
    \item \bt 将高级语言源程序转换为机器级目标文件的程序是(   ) 
    \begin{choices}
        \task 汇编程序 
        \task 链接程序 
        \task 编译程序 
        \task 解释程序
    \end{choices}

    \item 在计算机中,CPU的CPI与下列(   )因素无关.
    \begin{choices}
        \task 时钟频率 \task 系统结构 
        \task 指令集 \task 计算机组织 
    \end{choices}


    \item 某计算机主频为$1GHz$,程序P运行过程中,共执行了$10000$条指令,其中,$80\%$的指令执行平均
    需要1个始终周期,$20\%$的指令执行平均需10个时钟周期.程序P的平均CPI和CPU执行时间分别是(   ) 
    \begin{choices}
        \task $2.8,28\mu s$ 
        \task $28,28\mu s$
        \task $2.8,28ms$
        \task $28,28ms$ 
    \end{choices}
    

    \item 若$X$为负数,则由$[X]_{\text{补}}$求$[-X]_{\text{补}}$是将(   )
    \begin{choices}[1]
        \task $[X]_{\text{补}}$各值保持不变
        \task $[X]_{\text{补}}$符号位变反,其他位不变
        \task $[X]_{\text{补}}$除符号位外,其余位取反,末尾加一
        \task $[X]_{\text{补}}$连同符号位一起变反,末尾加一
    \end{choices}


    \item 对于相同位数(设N位,不考虑符号位)的二进制补码小数和十进制小数,二进制小数能表示的数的个数/十进制
    小说所能表示的个数为(  )
    \begin{choices}
        \task $(0.2)^{N}$
        \task $(0.2)^{N-1}$
        \task $(0.02)^{N}$
        \task $(0.02)^{N-1}$ 
    \end{choices}
    

    \item 设$x$为真值,$x^{*}$为其绝对值,满足$[-x^*]_{\text{补}}=[-x]_{\text{补}}$当且仅当x为(   ) 
    \begin{choices}
        \task 任意数
        \task 正数 
        \task 负数 
        \task 以上均不正确
    \end{choices}
    

    \item ALU作为运算器的核心部件,其属于(   ) 
    \begin{choices}
        \task 时序逻辑电路
        \task 组合逻辑电路
        \task 控制器 
        \task 寄存器
    \end{choices}
    
    \item 在串行进位的并行加法器中,影响加法器运算速度的关键因素是() 
    \begin{choices}[2]
        \task 门电路的级延迟 
        \task 元器件速度 
        \task 进位传递延迟 
        \task 各位加法器速度的不同
    \end{choices}

    \item 加法器中每位的进位信号由(   )组成
    \begin{choices}
        \task $X_i\oplus Y_i$
        \task $X_iY_i$
        \task $X_iY_iC_i$
        \task $X_i+Y_i+C_i$
    \end{choices}
    

    \item 一个8位寄存器内的数值为\underline{1100\ 1010}进位标志位寄存器C为0,若将此8位寄存器循环左移
    1位后,则该寄存器和标志寄存器的值分别为(   ) 
    \begin{choices}
        \task 1001\ 0100, 1
        \task 1001\ 0101, 0
        \task 1001\ 0101, 1
        \task 1001\ 0100, 0
    \end{choices}
    

    \item 设机器数字长8位(含一位符号位),若机器数为$BAH$为原码,算术左移1和算术右移1位分别得(   ) 
    \begin{choices}
        \task $F4H,EDH$
        \task $B4H,6DH$
        \task $74H,DDH$
        \task $B5H,EDH$
    \end{choices}
    

    \item 关于模4补码,下列说法中正确的是(   ) 
    \begin{choices}[1]
        \task 模4补码和模2补码不同,它不容易检查乘除运算中的溢出问题
        \task 每个模4补码存储时只需要存储一位符号位
        \task 存储每个模4补码需要存储两个符号位
        \task 模4补码,在算术与逻辑部件中为一个符号位
    \end{choices}


    \item 在原码一位乘法中,(   ) 
    \begin{choices}[1]
        \task 符号位参与运算
        \task 符号位不参与运算
        \task 符号位参与运算,并根据运算结果改变结果中的符号位
        \task 符号位不参与运算,并根据运算结果改变结果中的符号位
    \end{choices}


    \item \bl 某计算机字长为8位,CPU中有一个8位加法器.已知无符号数$x=69,y=38$,如果在该加法器中计算x-y,则加法
    器的两个输入端入端信息和低位进位信息分别是() 
    \begin{choices}[2]
        \task 0100\ 0101,0010\ 0110, 0
        \task 0100\ 0101,1101\ 1001, 1
        \task 0100\ 0101,1101\ 1010, 0
        \task 0100\ 0101,1101\ 1010, 1
    \end{choices}

    \item 某计算机中有一个8位加法器,带符号整数x和y的机器数用补码表示,$[x]_{\text{补}}=F5H$\\ 
    $[y]_{\text{补}}=7EH$如果在该加法器中计算$x-y$,则加法器的低位进位输入信息和运算后的溢出标志OF分别是()
    \begin{choices}
        \task 1,1 
        \task 1,0
        \task 0,1 
        \task 0,0
    \end{choices}

    \item \bt 某计算机存储器按字节编制,采用小端方式存放数据.假定编译器规定int型和short型长度分别为32位和16位
    并且数据按边界对齐存储.某C语言程序段如下
    \begin{center}
    \begin{lstlisting}[language=C]
    struct {
        int a;
        char b;
        short c;
    }record;
    record.a = 273;
    \end{lstlisting}
    \end{center}
    若record变量的首地址为0xC008地址0xC008中的内容及record.c的地址分别是()
    \begin{choices}
        \task 0x00, 0xC00D
        \task 0x00,0xC00E
        \task 0x11,0xC00D
        \task 0x11,0xC00E
    \end{choices}


    \item \bt 有如下C语言序段:
    \begin{lstlisting}[language=C]
    short si = -32767;
    unsigned short usi = si;
    \end{lstlisting}
    这执行上述两条语句后,usi的值是\_\_\_\_ 

    \item 某计算机字长为32位,按字节编址,采用小端方式存放数据,假定有一个$double$型变量,其机器数表示
    为1122\ 3344\ 5566\ 7788H,存放在以0000\ 8040H开始的连续存储单元中,则存储单元0000\ 8046H中存储的是(   )
    \begin{choices}
        \task 22H 
        \task 33H 
        \task 77H 
        \task 66H 
    \end{choices}
    

    \item 在规格化浮点运算中,若浮点数$2^5\times1.10101$,其中尾数为补码表示,则该数(   ) 
    \begin{choices}[2]
        \task 不需要规格化
        \task 需要右移规格化
        \task 需将尾数左移一位规格化
        \task 需将尾数左移二位规格化
    \end{choices}


    \item 某浮点机,采用规格化浮点数表示,阶码用移码表示(最高位表示符号位),尾数用原码表示,下列(   )表示不是规格化浮点数 
    \begin{choices}[2]
        \task 1111111, 1.10000...000
        \task 0011111, 1.0111...01
        \task 1000001, 0.11111...111
        \task 0111111, 0.100000000 
    \end{choices}


    \item 下列关于对阶操作说法正确的是(   ) 
    \begin{choices}[1]
        \task 在浮点数加减运算对阶操作中,若阶码减少,则尾数左移
        \task 在浮点数加减运算对阶操作中,若阶码增大,则尾数右移;若阶码减少,则尾数左移
        \task 在浮点数加减运算对阶操作中,若阶码增大,则尾数右移
        \task 以上说法都不对
    \end{choices}


    \item 浮点数的IEEE 754标准规定的64位浮点数格式中,符号位为1位,阶码为11位,尾数为52位,则它能表达的最小
    规格化负数为(\qquad),最大规格化负数为(\qquad),最小规格化正数为(\qquad),最大规格化正数为(\qquad)

    \item 采用规格化的浮点数最主要是为了(   ) 
    \begin{choices}[2]
        \task 增加数据的表示范围
        \task 方便浮点运算
        \task 防止运算时数据溢出
        \task 增加数据的表示精度 
    \end{choices}


    \item 设浮点数共12位,其中阶码以4位补码表示(1位符号),尾数用8位补码表示(1为符号).则该规格化浮点数
    所能表示的最大正数为(    ) 

    \item 若浮点数的尾数用补码表示,则下列(   )中的尾数是规格化形式 
    \begin{choices}
        \task 1.11000
        \task 0.01110
        \task 0.01010
        \task 1.00010 
    \end{choices}
    

    \item 设浮点数的基数为4,尾数用原码表示,则以下(   )是规格化的数 
    \begin{choices}
        \task 1.001101
        \task 0.001101
        \task 1.011011
        \task 0.000010 
    \end{choices}
    

    \item 下列关于舍入的说法,正确的是(多选)(   )
    \begin{enumerate}
        \item [(1)] 不仅仅只有浮点数需要舍入,定点数在运算时也可能舍入 
        \item [(2)] 在浮点数舍入中,只有左规格化时可能舍入
        \item [(3)] 在浮点数舍入中,只有右规格化时可能舍入
        \item [(4)] 在浮点数舍入中,左,右规格化时都可能舍入
        \item [(5)] 舍入不一定能产生误差
    \end{enumerate}

    \item \bt 假定变量$i,f,d$的数据类型分别是$int,float,double$(int用补码表示,其余用IEEE\ 754浮点
    数格式),已知$i=785,f=1.5678E3,d=1.5E100$,若在$32$位机器中执行下列关系表达式,则结果为真的是(多选)(   )
    \begin{enumerate}
        \item [(1)] $i==(int)(float)i$ 
        \item [(2)] $f==(float)(int)f$ 
        \item [(3)] $f==(float)(double)f$
        \item [(4)] $(d+f)-d==f$
    \end{enumerate}

    \item \bt $flota$类型数据通常用IEEE\ 754单精度格式表示,若编译器将$float$型变量$x$分配在一个
    32位浮点寄存器$FR1$中,且$x=-8.25$则$FR1$中的内容是\_\_\_\_ 

    \item \bt 下列关于浮点数加减运算中,正确的是(多选)(    )
    \begin{enumerate}
        \item [(1)] 对阶操作不会引起阶码上溢或下溢 
        \item [(2)] 右规和尾数舍入都可以引起阶码上溢 
        \item [(3)] 左规时可能引起阶码下溢 
        \item [(4)] 尾数溢出时结果不一定溢出 
    \end{enumerate}

    \item \bl $-0.4375$的$IEEE\ 754$单精度浮点数表示为(    ) 
    \begin{choices}
        \task BEE0\ 0000H \task BF06\ 0000H \task BF07\ 0000H \task C0E0\ 0000H
    \end{choices}

    \item \bt 假定用若干$2K\times 4$的芯片组成一个$8K\times 8$的存储器,则地址081FH所在芯片的
    最小地址是(    ) 
    \begin{choices}
        \task 0000H
        \task 0600H
        \task 0700H
        \task 0800H
    \end{choices}
    

    \item \bt 某计算机存储器按字节编址,主存地址空间大小为$64MB$,现用$4M\times 8$位的RAM芯片组成
    32MB的主存储器,则存储器地址寄存器$MAR$的位数至少是\_\_\_\_ 

    \item \bt 某磁盘的转速为$10000$转/分,平均寻道时间是$6ms$,磁盘传输速率是$20MB/s$磁盘控制器延迟
    为$0.2ms$,读取一个$4KB$的扇区所需要的平均时间约为(   ) 
    \begin{choices}
        \task $9ms$
        \task $9.4ms$
        \task $12ms$
        \task $12.4ms$
    \end{choices}
    

    \item \bt 假设主存地址为32位,按字节编址,主存和Cache之间采用直接映射方式,主存块大小为4个字,每个字32位,
    采用回写方式,则能存放4K字数据的Cache总容量的位数至少是(   ) \\
    A.146K\qquad B.147K\qquad C.148K\qquad D.158K 

    \item \bl 一个计算机系统采用32位单字长指令,地址码12位,若定义了250条二地址指令,则还可以有(   )单地址指令. \\
    A.4K\qquad B.8K\qquad C.16K\qquad D.24K 

    \item \bt 下列选项中,属于指令集体系结构(ISA)规定的内容是(多选)(    )
    \begin{enumerate}
        \item [(1)] 指令字格式和指令类型 
        \item [(2)] CPU的时钟周期 
        \item [(3)] 同样寄存器个数和位数 
        \item [(4)] 加法器的进位方式
    \end{enumerate}

    \item \bt 设计某指令系统时,假设采用16位定长指令格式,操作码使用拓展编码方式,地址码为6位,包括零
    地址,一地址和二地址三种指令.若二地址指令有12条,一地址指令有254条,则零地址指令的条数最多为(   )\\
    A.0\qquad B.2\qquad C.64\qquad D.128

    \item 指令系统中采用不同寻址方式的目的是(   )\\
    A.提供拓展操作码的可能性并降低译码难度 \\
    B.可缩短指令字长,托大寻址空间,提高编程的灵活性 \\
    C.实现程序控制 \\
    D.三者都正确 

    \item 简化地址结构的基本方法是尽量采用(   ) \\
    A.寄存器寻址\qquad B.隐含寻址\qquad C.直接寻址\qquad D.间接寻址 

    \item 在多道程序设计中,最重要的寻址方式是(   ) \\
    A.相对寻址\qquad B.间接寻址\qquad C.立即寻址\qquad D.按内容寻址
    
    \item 设相对寻址的转移指令占3B,第一字节为操作码,第二、三字节为相对位移量(补码 表示),
    而且数据在存储器中采用以低字节为字地址的存放方式。每当CPU从存储器取 出一字节时,
    即自动完成(PC)+1$\rightarrow$PC。若PC的当前值为240 (十进制),要求转移到 290 (十进制),
    则转移指令的第二、三字节的机器代码是();若PC的当前值为240 (十进制),要求转移到200 (十进制),
    则转移指令的第二、三字节的机器代码是().
    \begin{choices}
        \task 2FH,FFH 
        \task D5H,00H 
        \task D5H,FFH 
        \task 2FH,00H
    \end{choices}

    \item 某计算机有16个通用寄存器,采用32位定长指令字,操作码字段(含寻址方式位)为8位,Store指令的源操作数和目的操作数分别采用寄存器直接寻址和 基址寻址方式。
    若基址寄存器可使用任意一个通用寄存器,且偏移量用补码表示,则Store 指令中偏移量的取值范围是(   ) 
    \begin{choices}[2]
        \task $-32768\sim +32767$ \task $-32767\sim +32768$ 
        \task $-65536\sim +65535$ \task $-65535\sim +65536$ 
    \end{choices}


    \item 按字节编址的计算机中,某double型数组A的首地址为2000H,使用变址寻址和循环结构访问数组A,
    保存数组下标的变址寄存器的初值为0,每次循环取一个数组元素,其偏移地址为变址值乘以
    sizeof(double),取完后变址寄存器的内容自动加1。若某次循环所取元素的地址为2100H,
    则进入该次循环时变址寄存器的内容是(   )
    \begin{choices}
    \task 25 \task 32 \task 64 \task 100
    \end{choices} 

    \item 计算机使用总线结构便于增减外设,同时() 
    \begin{choices}[2]
        \task 减少信息传输量 
        \task 提高信息的传输速度 
        \task 减少信息传输线的条数 
        \task 提高信息传输的并行性 
    \end{choices}

    \item 间接寻址第一次访问内存所得到的信息经系统总线的()传送到CPU 
    \begin{choices}
        \task 数据总线 
        \task 地址总线 
        \task 控制总线 
        \task 总线控制器 
    \end{choices}

    \item 在单机系统中,三总线结构计算机的总线系统组成是() 
    \begin{choices}[1]
        \task 片内总线,系统总线和通信总线
        \task 数据总线,地址总线和控制总线 
        \task DMA总线,主存总线和I/O总线 
        \task ISA总线,VESA总线和PCI总线
    \end{choices} 
    
    \item \bl 假定一台计算机采用3通道存储器总线,配套的内存条型号为DDR3-1333,即内存条所接插的存储器总线
    的工作评率为1333MHz,总线宽度为64位,则存储器总线的总线带宽大约是()

    \item 在不同速度的设备之间传输数据,(  ) 
    \begin{choices}[1]
        \task 必须采用同步控制方式 
        \task 必须采用异步控制方式 
        \task 可以选用同步控制方式,也可以选用异步控制方式 
        \task 必须采用应答方式
    \end{choices}

    \item 在异步总线中,传送操作() 
    \begin{choices}[2]
        \task 由设备控制器控制 
        \task 由CPU控制 
        \task 有统一时序信号控制 
        \task 按需分配时间
    \end{choices}

    \item \bl 下列关于总线的叙述中,错误的是() 
    \begin{choices}[1]
        \task 总线是在两个或多个部件间进行数据交换的传输介质
        \task 同步总线由时钟信号定时,时钟频率不一定等于工作频率 
        \task 异步总线由握手信号定时,一次握手过程完成一位数据传送 
        \task 突发(Burst)传送总线事务可以在总线上连续传送多个数据 
    \end{choices}

    \item 下列关于I/O端口和接口的说法中,正确的是() 
    \begin{choices}[1]
        \task 按照不同的数据传送格式,可将接口分为同步传送接口和异步传送接口
        \task 在统一编址方式下,存储单元和I/O设备是靠不同的地址线来区分的 
        \task 在独立编址方式下,存储单元和I/O设备是靠不同的地址线来区分的 
        \task 在独立编址方式下,CPU需要设置专门的输入/输出指令的访问端口 
    \end{choices}

    \item 在统一编址情况下,就I/O设备而言,其对应的I/O地址说法错误的是() 
    \begin{choices}[2] 
        \task 要求固定的地址高端
        \task 要求固定的地址地段
        \task 要求相对固定在地址的某部分
        \task 可以任意在地址的任何地方
    \end{choices}

    \item 磁盘驱动器向盘片磁道记录数据时采用()方式写入 
    \begin{choices}
        \task 并行 \task 串行 \task 并行-串行 \task 串行-并行 
    \end{choices}

    \item \bl I/O指令实现的数据传送通常发生在() 
    \begin{choices}[2]
        \task I/O设备和I/O端口之间 
        \task 通用寄存器和I/O设备之间 
        \task I/O设备和I/O端口之间 
        \task 通用寄存器和I/O端口之间 
    \end{choices}

    \item 下列选项中,不属于I/O接口的是() 
    \begin{choices}[2]
        \task 磁盘驱动器 \task 打印机适配器 \task 网络控制器 \task 可编程中断控制器 
    \end{choices}

    \item 以下说法中,错误的是() 
    \begin{choices}[1]
        \task 中断服务程序一般是操作系统模块 
        \task 中断向量方法课提高中断源的识别速度 
        \task 中断向量地址是中断服务程序入口地址 
        \task 重叠处理中断现象称为中断嵌套 
    \end{choices}

    \item  关于程序中断和DMA方式叙述,错误的是() 
    \begin{enumerate}
        \item [(1)] DMA的优先级比程序中断的优先级更高
        \item [(2)] 程序中断方式需要保护现场,DMA方式不需要包含现场
        \item [(3)] 程序中断方式的中断请求是为了报告CPU数据的传输结束,而DMA方式的中断请求完全是为了传
        送数据 
    \end{enumerate}
    \begin{choices}
        \task 2 \task 2,3 \task 3 \task 1,3
    \end{choices}

    \item 中断响应优先级由高到低次序应该使用() 
    \begin{choices}[2]
        \task 访管,程序性,机器故障 
        \task 访管,程序性,重新启动 
        \task 外部,访管,程序性 
        \task 程序性,I/O,访管 
    \end{choices}

    \item 在具有中断向量表的计算机中,中断向量地址是() 
    \begin{choices}[2]
        \task 子程序入口地址 
        \task 中断服务程序入口地址 
        \task 中断服务程序入口地址的地址 
        \task 中断服务断点 
    \end{choices}

    \item 在配有通道的计算机系统,用户程序需要输入/输出时,引起中断的是(   ) 
    \begin{choices}
        \task 访管中断 \task I/O中断 \task 程序性中断 \task 外中断 
    \end{choices}

    \item 在中断响应周期中,CPU主要完成的工作是() 
    \begin{choices}[1]
        \task 关中断,保护断点,发中断响应信号并形成向量地址 
        \task 开中断,保护断点,发中断响应信号并形成向量地址 
        \task 关中断,执行中断服务程序 
        \task 开中断,执行中断服务程序  
    \end{choices}

    \item 设置中断屏蔽标致可以改变() 
    \begin{choices}[2]
        \task 多个中断源的中断请求优先级 
        \task CPU对多个中断请求响应的优先次序
        \task 多个中断服务程序开始执行的顺序 
        \task 多个中断服务程序执行完的次序 
    \end{choices}

    \item 下列叙述中,()时正确的 
    \begin{choices}[1]
        \task 程序中断方式和DMA方式中实现数据传送都需要中断请求
        \task 程序中断方式中有中断请求,DMA方式中没有中断请求
        \task 程序中断方式和DMA方式都有中断请求,但目的不同
        \task DMA要等指令周期结束时才可以进行周期窃取 
    \end{choices}

    \item 以下关于DMA方式进行I/O的描述中,正确的是() 
    \begin{choices}[1]
        \task 一个完整的DMA过程,不仅有DMA控制器控制,部分有CPU控制 
        \task 一个完整的DMA过程,完全有CPU控制 
        \task 一个完整的DMA过程,完全由DMA控制器控制,CPU不介入任何控制 
        \task 一个完整的DMA过程,完全由CPU采用周期挪用法控制
    \end{choices}

    \item 以下有关DMA方式的叙述中,错误的是() 
    \begin{choices}[1]
        \task 在DMA方式下,DMA控制器向CPU请求的是总线使用权 
        \task DMA方式可用键盘和鼠标的数据输入 
        \task 在数据传输阶段,不需要CPU介入,完全由DMA控制器控制 
        \task DMA方式要用中断处理 
    \end{choices}

    \item \bl 某计算机有五级中断$L_4\sim L_0$,中断屏蔽字为$M_4M_3M_2M_1M_0,M_i=1(0\leq i \leq 4)$表示队$L_i$级
    中断进行屏蔽,若中断响应优先级从高到低的顺序是$L_4,L_0,L_2,L_1,L_3$则$L_1$的中断处理程序中设置的中断屏蔽字是\_\_\_\_\_ 

    \item \bl 下列关于中断I/O方式和DMA方式比较的叙述中,错误的是() 
    \begin{choices}[1]
        \task 中断I/O方式请求的CPU控制时间,DMA方式请求的总线控制权 
        \task 中断响应发生在一条指令执行结束后,DMA响应发生在一条总线事务后 
        \task 中断I/O方式下数据传输通过软件完成,DMA方式下的数据有硬件完成 
        \task 中断I/O方式适用于所有外部设备,DMA方式适用于快速外部设备 
    \end{choices}

    \item \bl 若某设备中断请求的响应和处理时间为$100ms$,每$400ns$发出一次中断请求,中断响应所允许的
    最长延迟的时间$50ns$,则在该设备持续工作过程中,CPU用于该设备的I/O时间占CPU时间的百分比至少是() 
    \begin{choices}
        \task 12.5\% \task 25\% \task 27.5\% \task 50\%
    \end{choices}

    \item \bl 若某设备以中断方式与CPU进行数据交换,CPU主频为1GHz,设备接口中的数据缓冲寄存器为32位,设备的数据传输率
    为50kb/s.若每次中断开销(包含中断响应与中断处理)为1000个时钟周期,则CPU用于该设备输入/输出的时间占整个CPU时间的百分比
    至多是() 
    \begin{choices}
        \task 1.25\% \task 2.5\% \task 5\% \task 12.5\% 
    \end{choices}

    \item \bl 若设备采用周期挪用DMA方式进行输入和输出,每次DMA传送的数据块大小为512字节,响应的I/O接口中有一个
    32位数据缓冲寄存器.对于数据输入过程,下列叙述中,错误的是() 
    \begin{choices}[1]
        \task 每准备好32位数据,DMA控制器就发出一次总线请求 
        \task 相对于CPU,DMA控制器的总线使用权的优先级更高 
        \task 在整个数据块的传送过程中,CPU不可以访问主存储器
        \task 数据块传送结束后,会产生"DMA传送结束"中断请求
    \end{choices}

    \item \bl 下列关于中断I/O方式的叙述中,不正确的是() 
    \begin{choices}[1]
        \task 适用于键盘,针式打印机等字符型设备 
        \task 外设和主机之间的数据传送通过软件完成
        \task 外设准备数据的时间应小于中断处理时间 
        \task 外设为某进程准备数据时CPU可运行其他进程
    \end{choices}
\end{enumerate}

\newpage 

\subsection{强化1 000题}
\begin{enumerate}
    \item 下面各选项不属于指令集架构ISA描述的内容是(\qquad)
    \begin{choices}[2]
        \task 指令的寻址方式
        \task 指令的操作码的个数
        \task 乘法器的设计方式
        \task 通用寄存器组的编号
    \end{choices} 

    \item 加法器实现采用并行进位方式还是串行进位方式属于计算机体系结构中的(\qquad)层
    \item 下列说法正确的是(\qquad)
    \begin{choices}[1]
        \task 在冯若依曼计算器中,指令流是由数据流驱动的
        \task 执行指令时,指令在主存中的地址存放在指令寄存器中
        \task 指令周期是指CPU从主存中读出一条指令的时间
        \task 在单周期的五级流水处理器中,取指周期的操作与指令的操作码无关
    \end{choices}

    \item $[x]_{\text{补}}=X_0,.X_1X_2\ldots X_n$ 它的模是(\qquad)
    \item 数值数据和逻辑数据在形式上没有区别,计算机区分数值数据和逻辑数据的主要方法是(\qquad)
    \item 一个8位二进制整数由2个0和6个1组成,采用补码或者移码表示,则下列说法正确的是(\qquad)
    \begin{choices}[1]
        \task 若采用移码表示,偏置值为127,则此整数的最小为-64
        \task 若采用移码表示,偏置值为128,则此整数的最大为123
        \task 若采用补码表示,则此整数的最小为-96
        \task 若采用补码表示,则此整数的最大为252
    \end{choices}

    \item 用12位补码规格化表示定点小数的时候,所能表示的正数范围是(\qquad)
    \item 在补码的除法运算中,若采用不恢复余数法,当余数为负的时候,下一步操作为(\qquad)
    \item 下列关于运算电路正确的是(\qquad)
    \begin{choices}[1]
        \task 乘法运算电路只能通过加法器和移位器来实现
        \task 减法运算电路与加法运算电路的硬件结构完全相同
        \task 实现除法运算的电路比乘法电路复杂
        \task 基本运算部件中的全加器不能进行减法运算
    \end{choices}
    \item 下列关于Booth补码一位乘法算法的描述中,错误的是(\qquad)
    \begin{choices}[1]
        \task 符号位与数值位同时进行运算,无须专门的符号生成部件
        \task 通过循环执行"加/减"和"移位"得到乘积
        \task 有乘数的最低两位决定对部分积和被乘数进行何种运算
        \task 移位时,将进位位,部分积和乘积部分一起进行算法右移
    \end{choices}

    \item 对于两个n为无符号整数的除法运算,以下关于不恢复余数算法要点的描述中,错误的是(\qquad)
    \begin{choices}[1]
        \task 起始时被除数的高位拓展n位0,以将其拓展为2n位无符号整数
        \task 位判断中间余数的正负,需要在余数寄存器的最高位前添加一位符号位
        \task 至少需要n+1次循环执行"加/减"和移位操作才能得到位商
        \task 运算结果一定不会发生溢出,故无需通过最高位的位商来判断是否溢出
    \end{choices}

    \item 已知无符号数$X=10101010B,Y=01010101B$,若进行$X-Y$则结果为(\qquad)
    \item 若浮点数阶码用4位移码表示,尾数用8位补码表示(含符号位),规格化的正的尾数的范围是(\qquad)
    \item 设机器字长为16位,表示浮点数的时候,阶符占1位,阶码数值占5位,数符占1位,浮点数的阶码和数值部分都用补码表示,
    则可以表示的最大值为(\qquad)
    \item 设浮点数阶码的基数为8,尾数用补码表示,则下列浮点数尾数中的规格化数是(\qquad)
    \item IEEE754标准提供四种舍入模式,其中(\qquad)模式平均误差最小
    \item 对于IEEE754单精度浮点数的对阶过程,需要计算两个阶码$E_x,E_y$之差的补码$[\Delta E]_{\text{补}}$,若$\Delta \geq 128$或者
    $\Delta \leq -129$,则其发生溢出,假定$[E_x]_{\text{移}},\left[-[E_y]_{\text{移}}\right]_{\text{补}},[\Delta E]_{\text{补}}$的 
    最高有效位分别记作$E_{xs},E_{ys},E_{bs}$则相应的溢出判断方程是(\qquad)
    \item 下列关于浮点数加减运算中说法正确的是(\qquad)(多选)
    \begin{choices}[1]
        \task 当浮点数执行舍入操作时,会引起阶码下溢
        \task 当浮点数左规引起阶码下溢,则按照机器零处理
        \task 浮点数执行对阶操作,不会引起阶码溢出
        \task 单精度浮点数能表示的最大规格化负数为$-2^{-126}$
    \end{choices}
    \item 对于IEEE754单精度浮点数的对阶过程,只要对阶时候两个阶码之差的绝对值大于等于(\qquad)就无需后续处理,直接取阶码大的即可
    \item 对于IEEE754单精度浮点数a,b,假设$a=00840000,b=00800000H$,则同为float浮点数$c=a-b$的机器数是(\qquad),若$float\ d=c+b$,则
    $d==a$返回(\qquad)
    \item 在计算机内部,浮点数往往采用IEEE754格式进行存储,那么在某计算机中,浮点数x的机器数为$43322000H$,浮点数y的机器数为$C14C000H$,则
    $x-y$的机器数是(\qquad)
    \item 若两个float类型的浮点数x,y,x的机器数为$50280001H$,y的机器数是$44000000H$,计算$z=x+y$运算时保留两个附加位采用就近舍入,则
    下列说法正确的是(\qquad)(多选)
    \begin{choices}[1]
        \task y要向x对阶
        \task 舍入过程中无进位
        \task 运算无溢出
        \task z-x == y 为真
    \end{choices}

    \item 执行下列C语言程序后$i$的值是(\qquad)
    \begin{lstlisting}[language=C]
    char c = -1;
    unsigned int u = c;
    float f = u;
    double i = f;
    \end{lstlisting}

    \item 假定编译器规定int型和short型长度分别为32位何16位,执行下列C语言语句,得到y的机器数是(\qquad)
    \begin{lstlisting}{language=C}
    unsigned short x = 65530;
    int y = x;
    \end{lstlisting}

    \item 判断正误
    \begin{choices}[1]
        \task 模4补码与模2补码不同,它更容易检查乘除运算中的溢出问题
        \task 在小数除法中,为避免溢出,要求被除数的绝对值小于除数的绝对值
        \task 可以通过直接访问标志寄存器,并修改它的值
        \task 快速阵列乘法器中的基本部件包括移位器
        \task 不恢复余数的除法运算不存在恢复余数的操作
        \task 将补码的符号位改用多位来表示,就变成了变形补码,一个用双符号位表示的变形补码01.1010是正数
        \task 所有进位计数制,其整数部分最低位位权都是1
        \task 某R进位计数制,其嘴边1为的权是其相邻右边1位权的R倍
        \task 从int转换为float,数值可能溢出
        \task 从int转换为double,数据不会溢出
        \task 从double转换为float,数据可能溢出也能舍入
        \task 从double转换为int,数据可能舍入
    \end{choices}

    \item Flash存储器的特点不包括(\qquad)
    \begin{choices}[2]
        \task 非易失性,断电后数据不丢失 
        \task 可点擦除与编程
        \task 读操作速度解决SRAM
        \task 写比读操作更快
    \end{choices}

    \item 容量1Mx16位的DRAM存储芯片,如果采用二维地址结构,且行地址和列地址的位数相同,行译码器输出的行选择线有(\qquad),该
    芯片的刷新地址计数器是(\qquad)位

    \item 有一个16Kx16的存储器,有4kx4的DRAM芯片(内部存储阵列为64x64)构成,采用集中刷新,刷新间隔为2ms,存储器的读写周期为0.5us,
    死时间率约为(\qquad)

    \item 某机器的主存储器为32MB,由若干片16KB(内部采用128x128存储阵列)的DRAM芯片字和位同时扩展构成。若采用集中式刷新方式,
    且刷新周期为2ms,那么所有存储单元刷新一遍需要(\qquad)个存储周期。

    \item  对于某存储芯片,假定动态刷新间隔为2ms,读写周期和刷新周期均为0.2us,该芯片中包含128行,每个刷新周期
    可以完成1行存储单元的刷新,如果该芯片采用异步刷新方式工作,那么其读写周期和刷新周期可以安排为(\qquad)

    \begin{choices}[1]
        \task 3999次读写周期后,安排一次刷新操作
        \task  2000次读写周期后,安排一次刷新操作
        \task 128次读写周期后,安排一次刷新操作
        \task 64次读写周期后,安排一次刷新操作
    \end{choices}

    \item 某容量为256MB的存储器由若干64Kx8位的DRAM芯片构成,按异步刷新方案,2ms内将全部单元刷新一遍。则芯片刷新信号周期时间为(\qquad)
    \item 某存储器按字节编址,地址$0000\sim FFFFH$为RAM区,若采用16Kx2的RAM芯片进行设计,则在字方向和位方向上分别拓展了(\qquad)和(\qquad)倍呢?
    \item 假定主存地址空间大小为1024MB,按字节编址,每次读/写操作最多可以一次存取32位.不考虑其他因素,则存储器地址寄存器MAR和存储器数据寄存器MDR的位数
    至少应该分别为(\qquad)和(\qquad)
    \item 假定DDR3\ SDRAM芯片内部核心频率为133.25MHz,与之相连的存储器总线每次传输8B,则下面有关叙述错误的是(\qquad)
    \begin{choices}[1]
        \task 芯片内部I/O缓冲采用8位预取技术
        \task 存储器总线每秒传1066M次数据
        \task 存储器总线的时钟频率为1066MHz
        \task 存储器总线的带宽大约为8.5GB/s
    \end{choices}
    \item 某计算机使用4体低位交叉编址存储器,存取周期T=80ns,总线启动访问间隔Δt=20ns。在存储器总线上出现的主存地址(十进制)序列为
    8005,8006,8007,8008,8001,8002,8003,8004,8000,则总存取时间是(\qquad).(到最后一次存取的存取周期结束为止)

    \item 设存储器容量为512K字, 字长32位, 模块数=8,用交叉方式进行组织, 采用突发传送,一次突发传送8个字. 存储周期T=200ns,
    数据总线宽度为32位, 总线传送周期T=50ns,则交叉存储器带宽是(\qquad)b/s.

    \item 下列关于固态硬盘(SSD)的说法中, 错误的是(\qquad).(多选)
    \begin{choices}[1]
        \task 固态硬盘不受震动和物理冲击的影响, 更适合移动设备使用.
        \task 固态硬盘的磨损均衡技术中, 动态磨损均衡比静态磨损均衡技术更先进、表现更优秀.
        \task 固态硬盘的数据存储于Flash芯片之中.
        \task 机械硬盘使用的硬盘调度算法不一定适用于固态硬盘.
    \end{choices}

    \item 下列关于固态硬盘SSD的说法中, 正确的有(\qquad)(多选)
    \begin{choices}[1]
        \task 固态磁盘是基于闪存技术的存储技术
        \task 固态磁盘在写入前必须进行擦除
        \task 固态磁盘的读写性能、使用寿命均优于机械硬盘
        \task 固态硬盘写入时, 总是要选择擦写次数少的存储块
    \end{choices}

    \item 下列关于cache的描述中, 正确的是(\qquad)
    \begin{choices}[1]
        \task cache行越大越好, 这样可以提高cache命中率
        \task 直接映射方式无需考虑替换方式
        \task cache可以看作内存的扩充
        \task 在多级cache系统中, 主存侧的cache通常将指令和数据分开, 用两个cache存储
    \end{choices}

    \item 已知cache-主存系统效率为85\%, 平均访问时间为60ns,cache比主存快4倍, 先访问cache, 未命中再访问主存,
    则cache命中率是(\qquad).

    \item 已知cache命中率H=0.98, 主存周期是cache的4倍,主存存取周期为200ns, 先访问cache, 未命中再访问主存,
    则cache-主存的效率为(\qquad).

    \item 有如下c语言段,数组a中都是int型数据,数组长度为72,每个int型数据占4B,假定数组a在主存中是从$00000000H$开始存储,其中数据
    Cache采用4路组相联,数据区大小为256B,cache行(主存块)大小为16B,采用LRU替换算法该程序段执行前Cache为空,则该程序执行过程中访问数组a的
    cache命中率是多少?(\qquad)
    \begin{lstlisting}[language=C]
    for(int i = 0; i < 10; ++i)
        for(int j = 0; j < 72; ++j)
            a[j] = a[j] + c;
    \end{lstlisting}

    \item 某32位计算机的cache容量为16KB, cache行的大小为16B,若主存与cache地址映射采用直接映射方式,
    则主存地址为0x1234E8F8的单元装入cache的地址是(\qquad).

    \item 关于Cache的全写法(写直达法)和写回法这两种写策略,以下说法正确的是(\qquad).
    \begin{choices}[1]
        \task 采用写回法时, 只有在第一次写入Cache时需要写入主存
        \task 采用全写法时, 写命中时则同时写Cache和辅存
        \task 采用写回法时, 每块Cache都需要多加一位辅助位
    \end{choices}

    \item 假定页表有一个控制位C, 用来表示对应页面是否可在Cache缓存.C=1表示可在Cache缓存, C=0表示不可在Cache缓存.
    以下关于虚实地址转换时对C进行相关处理的描述, 其中错误的是(\qquad).
    \begin{choices}[1]
        \task 若装入位为0, 则无需考虑C的取值如何
        \task 若修改位为1, 则不管C原来的值如何都将其清0
        \task 若C=0, 则根据转换后的地址直接访问主存而不访问Cache
        \task 若C=1, 则根据转换后的地址先到Cache中进行访问
    \end{choices}

    \item 假定编译器将赋值语句"x=x+3;"转换为指令"add xaddt, 3",其中xaddt是x对应的存储单元地址,若执行该指令的计算机采用页式虚拟存储管理方式,
    并配有相应的TLB, 且Cache使用直写方式,完成该指令的功能, 需要访问主存的次数最少是(\qquad)次.

    \item 下列关于cache缺失和TLB缺失的说法, 错误的是(\qquad)
    \begin{choices}[1]
        \task cache缺失无需进行进程切换
        \task cache缺失处理由硬件实现
        \task TLB缺失, 需要执行TLB缺失异常处理
        \task TLB缺失, cache不一定缺失
    \end{choices}

    \item 以下是有关段式存储管理的叙述, 其中错误的是(\qquad)
    \begin{choices}[1]
        \task 段是逻辑结构上相对独立的程序块, 因此段是可变长的
        \task 按程序中实际的段来分配主存, 所以分配后的存储块是可变长的
        \task 每个段表项必须记录对应段在主存的起始位置和段的长度
        \task 分段方式对低级语言程序员和编译器来说是透明的
    \end{choices}

    \item 指令系统的兼容性是指(\qquad)
    \begin{choices}[1]
    \task 不同计算机的指令系统完全一样
    \task 同一计算机的指令系统在不同操作系统下都能运行
    \task 一种计算机的目标程序可以不加修改地在另一种计算机上运行
    \task 指令系统能同时支持多种高级语言
    \end{choices}

    \item 在指令格式中采用扩展操作码的设计方案是为(\qquad)
    \begin{choices}[1]
    \task 减少指令字长度
    \task 增加指令字长度
    \task 保持指令字长度不变
    \task 保持指令字长度不变,而增加寻址空间
    \end{choices}

    \item 零地址的运算类指令在指令格式中不给出操作数地址,参加的两个操作数来自(\qquad)
    \begin{choices}[1]
    \task 累加器和寄存器
    \task 累加器和暂存器
    \task 堆栈的栈顶和次栈顶单元
    \task 暂存器和堆栈的栈顶单元
    \end{choices}

    \item 偏移量存储在寄存器中的寻址方式为(\qquad)
    \begin{choices}[2]
    \task 变址寻址
    \task 基址寻址
    \task 相对寻址
    \task 间接寻址
    \end{choices}

    \item 假设地址为 1200H 的内存单元中的内容为120CH,地址为 120CH的内存单元的内容为 38B8H,
    而38B8H单元的内容为88F9H,下列说法正确的(\qquad)(多选)
    \begin{choices}[1]
        \task 操作数采用变址寻址,变址寄存器中存放内容的值是12,指令中的形式地址为1200H,那么有效地址为1212H 
        \task 操作数采用一次间接寻址,指令中给出的地址码为120CH,那么操作数为38B8H
        \task 操作数采用寄存器间接寻址,指令中给出的寄存器编号为8,8号寄存器的内容为1200H,有效地址为120CH
    \end{choices}

    \item 以下关于 CISC 和 RISC 的说法,正确的是(\qquad)
    \begin{choices}[1]
    \task CISC 更适合用于对性能要求高的实时系统
    \task RISC 的硬件实现复杂度比 CISC 高
    \task CISC 的编程灵活性比 RISC 好
    \task RISC 的指令系统指令数目比 CISC 多
    \end{choices}

    \item 当高级语言中的函数调用转换为机器级代码时,以下操作顺序正确的是(\qquad)
    \begin{choices}[1]
    \task 保存现场→传递参数→执行函数体→恢复现场→返回
    \task 传递参数→保存现场→执行函数体→恢复现场→返回
    \task 传递参数→执行函数体→保存现场→恢复现场→返回
    \task 保存现场→执行函数体→传递参数→恢复现场→返回
    \end{choices}


    % 缺CPU章节
    \item 总线中,有些信息是单向传输的,有些信息是双向传输的,下列说法中,正确的是(\qquad)
    \begin{choices}[1]
    \task 数据信息是单向传输的,由内存或者外设传送至CPU
    \task 地址信息是单向传输的,由CPU发送至内存或者外设
    \task 控制信息是单向传输的,由CPU发送至内存或者外设
    \task 状态信息是双向传输的,由CPU发送至内存或者外设,也可反向
    \end{choices}

    \item 下列属于I/O接口中寄存器的有(\qquad)\\
    I.指令寄存器\quad
    II.控制寄存器\quad
    III.状态寄存器\quad
    IV.地址寄存器\quad
    V.数据缓冲寄存器
    \begin{choices}[2]
    \task I、II、III、V
    \task II、III、IV
    \task II、III、V
    \task II、III、IV、V
    \end{choices}

    \item 独立编址方式下,可以实现从I/O端口到CPU寄存器的数据传输的指令是(\qquad)
    \begin{choices}
    \task OUT指令
    \task WRITE指令
    \task READ指令
    \task IN指令
    \end{choices}

    \item 下列关于程序查询方式的叙述,正确的是(\qquad)
    \begin{choices}[1]
    \task CPU在与硬盘交换信息时,一般采用程序查询方式
    \task 按启动查询方式的不同,可分为软件查询方式和硬件查询方式
    \task 适用于鼠标、针式打印机等字符类设备
    \task CPU需要一直查询外设的状态,直到设备准备就绪时才可以进行数据传输
    \end{choices}

    \item 下列关于程序查询方式工作过程的叙述,正确的是(\qquad)
    \begin{choices}[1]
    \task 当CPU查询到外设状态没有准备就绪时,会重启外设
    \task CPU主要负责启动外设和查询其状态,不参与数据传送
    \task 当数据没有传送完时,CPU必须重启外设,继续进行下一轮传送
    \task 每完成一次数据传送后,会修改主存地址和计数值
    \end{choices}

    \item 在某台计算机中,处理器的主频为100\,MHz,处理器与硬盘之间通过程序中断的方式传输数据,每次最多传送4\,字节数据,传输速率为100\,KB/s,每次传输需要100个CPU时钟周期。那么CPU处理硬盘I/O的时间占整个CPU时间的百分比是(\qquad)
    \begin{choices}
    \task 0.5\%
    \task 2.5\%
    \task 4\%
    \task 5\%
    \end{choices}

    \item 下列关于中断向量的说法,错误的是(\qquad)
    \begin{choices}[1]
    \task 中断向量指的是标识中断类型的编号
    \task 中断向量地址在中断响应阶段由硬件产生
    \task 中断向量表记录了中断号和中断向量地址的对应关系
    \task 中断向量表记录了各中断的优先级
    \end{choices}

    \item 关于DMA控制器的说法,错误的是（）
    \begin{choices}[1]
    \task 字计数器的作用是记录数据块的长度,每传送1个字(节),计数减1,到0时DMA控制器发出DMA中断
    \task DMA控制器是通过执行DMA中断服务程序来完成数据传输的
    \task 一般要用到两个地址寄存器设置源/目设备地址
    \task 传输的方向跟控制寄存器有关
    \end{choices}

    \item 以下是有关对DMA方式的叙述,其中正确的有(\qquad)个\\
    I.DMA方式下,在主存和外设之间有一条物理通路直接相连\\
    II.DMA方式一般不用于键盘和鼠标器的数据输入\\
    III.在进行数据传送之前,通过硬件完成对DMA控制器中各参数寄存器的初始值的设定\\
    IV.发生缺页中断时,若在缺页处理程序中将缺页调入内存采用DMA方式,则需要把磁盘物理地址写入DMA控制器中的设备地址寄存器DAR,把页表基地址写入其主存地址寄存器AR\\
    V.在DMA的后处理中,如果还要继续传送,则不需要再对DMA接口进行初始化\\
    VI.采用周期挪用时,发生访存冲突时,CPU在访存事务结束后挪用一个主存存取周期给DMA
    \begin{choices}
    \task 2
    \task 3
    \task 4
    \task 5
    \end{choices}

    \item 中断方式和DMA方式是两种典型的I/O控制方式。下列关于中断方式与DMA方式的说法错误的是(\qquad)
    \begin{choices}[1]
    \task 从本质上讲,中断方式以软件方式传输数据,DMA方式以硬件方式传输数据
    \task 当CPU运行中断处理程序时,若外设发出DMA请求信号,则CPU中断当前中断处理程序的运行,处理DMA请求,处理完毕后,继续运行原中断处理程序
    \task 对中断请求的响应只能发生在每个指令周期结束时,对DMA请求的响应可以发生在每个总线事务结束后
    \task 中断方式传输数据时需要保护原程序的现场,DMA方式传输数据时无须保护现场
    \end{choices}

    \item DMA传送过程分为预处理、数据传输和后处理3个阶段,下列操作在数据传输阶段进行的是(\qquad)\\
    I.主存地址寄存器的自增和字计数器的自减\\
    II.确定数据传输方向\\
    III.校验数据正确性\\
    IV.设备选择\\
    V.DMA控制器申请总线控制权
    \begin{choices}
    \task I、V
    \task I、II、IV
    \task I、III、IV
    \task II、IV、V
    \end{choices}

    \item DMA的传送方式可分为停止CPU访存、周期挪用、DMA与CPU交替访存3种方式。下列说法错误的是(\qquad)
    \begin{choices}[1]
    \task 停止CPU访存方式适用于高速I/O设备进行DMA传输
    \task 周期挪用方式适用于I/O设备的读写周期大于存取周期的情况
    \task DMA与CPU交替访存适用于总线周期大于存取周期的情况
    \task 周期挪用方法可以兼顾I/O传送的及时性和CPU访问内存的效率
    \end{choices}

    \item 判断正误
    \begin{choices}[1]
        \task 采用数据/地址线复用技术,总线中保留地址线,不会设置数据线,数据通过地址线传输
        \task 串行传输总线的速度可以比并行传输总线快得多
        \task I/O接口就像显卡和网卡之类的一种外设控制逻辑
        \task 中断控制器不属于I/O接口
        \task 中断控制器与外部设备的设备控制器直接相连
    \end{choices}
\end{enumerate}

\newpage
\section{选择题答案}
\begin{enumerate}[label=\arabic*.\textbf{答案}:]
\item A;冯诺依曼体系结构的基本工作方式:控制流驱动方式;基本特点:按地址访问并顺序执行(存储程序). 
\item C;
\begin{center}
\begin{tabular}{c|c}
    \hline 
    程序编译过程 & 具体作用 \\ 
    \hline 
    预处理程序 & 展开程序中的宏定义和头文件  \\
    \hline 
    编译程序 & 将高级语言转换为编译语言文件(.s)或者直接转换为(.o)文件 \\
    \hline 
    汇编程序 & 将汇编语言程序转换为机器语言目标文件(.o) \\
    \hline 
    链接程序 & 将多个(.o)文件链接形成二进制可执行文件 \\
    \hline  
    解释程序 & 它一边读取源代码（或字节码等中间表示一边立即将其翻译成机器 \\
    {}     &  能直接执行的指令序列并立即执行,而不生成单独的可执行文件 \\
    \hline 
\end{tabular}
\end{center}
\item A \\
这道题有种高中的时候计算式和决定式的味道了.CPI(每条指令的平均时钟周期数)只与指令集、系统结构、
计算机组织等“每拍做什么”有关;时钟频率决定“每秒多少拍”.并不改变一条指令需要多少拍,因此与CPI无关. 

\item A 
\item D
\item A, N位二进制小数可以表示的个数为 $1+2^0+2^1+\ldots+2^{N-1}=2^N$, 十进制小时能表示的个数为 $10^N$,二者比值为
$(0.2)^N$, 这表明{\color{red} 仅有$(0.2)^N$ 的概率一个十进制数可以由二进制数精确表示} 

\item D, 当x为0或者负数的时候成立 
\item B, ALU是无时钟无寄存器的纯逻辑原件的组合电路
\item C, 串行进位（行波进位）加法器里,高位的和必须等低位的进位到来才能形成,
因此整个运算时间取决于进位信号从最低位传到最高位所需的时间
\item B, 进位信号为$X_iY_i$, 向高位输出的信号$C_{i+1} = X_iY_i + (X_i + Y_i)C_i$ 或者
$C_{i+1} = X_iY_i \oplus (X_i + Y_i)C_i$二者等价
\item C, 注意题干{\color{red} 循环} 左移
\item C, 注意算术右移要填充符号位,逻辑右移不需要
\item B, 由于任意一个正确模4补码双符号为必然一致,故存储数值的时候需要1位.但送入ALU的时候需要将符号位拓展为双符号位
进行计算,输出结果若正常则存储否则发生溢出进行溢出处理而非被存储. 
\item B, 原码乘法中,符号位率先计算 $P_n = X_n \oplus Y_n$ (符号位做异或操作)
\item B, 注意加法器的电路,运行减法的是否 $sub=1$,并且$sub$会与所有$Y_i$做异或操作后才进入输入端, 并且不要忘记$sub$是需要
作为$C_0$参与计算, 这一步是为了实现按位取反+1.
\item A
\item D 
\item 32769, 注意到$2^{15} = 32768$ 故$-32767 = 8001H$, 转换为无符号数即$2^{15}+1=36769$
\item A, 小端法:低地址存地位;大端法:低地址存高位(和日常书写一致)
\item C, 补码浮点数的规格化尾数类型为{\color{red} 1.0xxxx},此时只需左移1位即可
\item B, 题目没说按照IEEE754的标准, 考虑最简单尾数规格化需要保证第一有效位为1,即尾数部分对于整数0.1xxx,对于负数1.1xxxx 
\item C, 浮点数对阶只会使的阶码小的往阶码大的靠齐,不存在将大阶码降为小阶码的可能性. 
\item 
\begin{enumerate}
    \item 最小规格化负数为(s=1,E=2046,尾数全1: $(-1.1111\ldots1111)\times 2^{2046-1023}=-(2-2^{-52})\times 2^{1023})$ 
    \item 最大规格化负数为(s=1,E=1,尾数全0: $(-1.00000\ldots000)\times 2^{1-1023}=-2^{-1022}$)
    \item 最大规格化正数为(s=0,E=2046,尾数全1) 
    \item 最小规格化正数为(s=0,E=1,尾数全0)
\end{enumerate}
\item $2^7 - 1$
\item D, 补码规格化尾数类型为{\color{red} 1.0xxxx}
\item C, 基为4表明尾数的值要满足$\left| M \right| \in [1/4, 1)$,原码表示下只需要保证小数点后两位不
全为0即可
\item (5), 浮点数仅在对阶和右规的时候可能发生舍入. 舍入通过设置附件位能保证一定的精度,并不一定总会丢失精度 
\item 1,3, 想太多并没用考虑最简单的思路,int->float必然会丢失小数,float->double不会发生精度丢失即可.此为
注意浮点数计算需要对阶,double+float很可能会吸收掉小数. 
\item C104000H, 需要数量掌握IEE754的转换方法 
\item 1,2,3,4, {\color{red} 浮点数仅当阶码溢出的时候才会发生溢出}
\item A, 首先需要将这个数转换为IEEE754的规格化类型$-1.75\times 2^{-2}$
\end{enumerate}
\section{综合题答案}
\ifx\allfiles\undefined
\end{document}
\fi