\ifx\allfiles\undefined
\documentclass[12pt, a4paper, oneside, UTF8]{ctexbook}
\def\path{../config}
\input{../config/_config}
\begin{document}
% \input{../config/cover}
\else
\fi
\chapter{计算机组成原理}

\section{选择题}
\begin{enumerate}
    \item 冯$\cdot$诺依曼机的基本工作方式是(  ) \\
    A.控制流驱动方式\qquad B.多指令多数据流方式 \\
    C.微程序控制器\qquad C.数据流驱动方式 
    
    \item \bt 将高级语言源程序转换为机器级目标文件的程序是(   ) \\
    A.汇编程序\qquad B.连接程序\qquad C.编译程序\qquad D.解释程序 

    \item 在计算机中,CPU的CPI与下列(   )因素无关.\\
    A.时钟频率\qquad B.系统结构\qquad C.指令集\qquad D.计算机组织 

    \item 某计算机主频为$1GHz$,程序P运行过程中,共执行了$10000$条指令,其中,$80\%$的指令执行平均
    需要1个始终周期,$20\%$的指令执行平均需10个时钟周期.程序P的平均CPI和CPU执行时间分别是(   ) \\
    A.$2.8,28\mu s$\qquad B.$28,28\mu s$\qquad C.$2.8,28ms$\qquad D.$28,28ms$ 

    \item 若$X$为负数,则由$[X]_{\text{补}}$求$[-X]_{\text{补}}$是将(   ) \\
    A.$[X]_{\text{补}}$各值保持不变 \\
    B.$[X]_{\text{补}}$符号位变反,其他位不变 \\
    C.$[X]_{\text{补}}$除符号位外,其余位取反,末尾加一 \\
    D.$[X]_{\text{补}}$连同符号位一起变反,末尾加一 

    \item 对于相同位数(设N位,不考虑符号位)的二进制补码小数和十进制小数,二进制小数能表示的数的个数/十进制
    小说所能表示的个数为(  ) \\
    A.$(0.2)^{N}$\qquad B.$(0.2)^{N-1}$\qquad C.$(0.02)^{N}$\qquad D.$(0.02)^{N-1}$ 

    \item 设$x$为真值,$x^{*}$为其绝对值,满足$[-x^*]_{\text{补}}=[-x]_{\text{补}}$当且仅当x为(   ) \\
    A.任意数 \qquad B.正数\qquad C.负数\qquad D.以上说法均不正确

    \item ALU作为运算器的核心部件,其属于(   ) \\
    A.时序逻辑电路\qquad B.组合逻辑电路\qquad C.控制器\qquad D.寄存器 

    \item \bl 加法器中每位的进位信号由(   )组成\\
    A.$X_i\oplus Y_i$\qquad B.$X_iY_i$ \qquad C.$X_iY_iC_i$\qquad D.$X_i+Y_i+C_i$ 

    \item 一个8位寄存器内的数值为\underline{1100\ 1010}进位标志位寄存器C为0,若将此8位寄存器循环左移
    1位后,则该寄存器和标志寄存器的值分别为(   ) \\
    A.1001\ 0100, 1\qquad B.1001\ 0101, 0\qquad C.1001\ 0101, 1\qquad D.1001\ 0100, 0

    \item 设机器数字长8位(含一位符号位),若机器数为$BAH$为原码,算术左移1和算术右移1位分别得(   ) \\
    A.$F4H,EDH$\qquad B.$B4H,6DH$\qquad C.$74H,DDH$\qquad D.$B5H,EDH$ 

    \item 关于模4补码,下列说法中正确的是(   ) \\
    A.模4补码和模2补码不同,它不容易检查乘除运算中的溢出问题 \\
    B.每个模4补码存储时只需要存储一位符号位 \\
    C.存储每个模4补码需要存储两个符号位\\ 
    D.模4补码,在算术与逻辑部件中为一个符号位 

    \item 在原码一位乘法中,(   ) \\
    A.符号位参与运算 \\
    B.符号位不参与运算 \\
    C.符号位参与运算,并根据运算结果改变结果中的符号位 \\
    D.符号位不参与运算,并根据运算结果改变结果中的符号位

    \item \bl 某计算机字长为8位,CPU中有一个8位加法器.已知无符号数$x=69,y=38$,如果在该加法器中计算x-y,则加法
    器的两个输入端入端信息和低位进位信息分别是() \\
    A.0100\ 0101,0010\ 0110, 0 \qquad B.0100\ 0101,1101\ 1001, 1 \\
    C.0100\ 0101,1101\ 1010, 0 \qquad D.0100\ 0101,1101\ 1010, 1

    \item \bt 某计算机存储器按字节编制,采用小端方式存放数据.假定编译器规定int型和short型长度分别为32位和16位
    并且数据按边界对齐存储.某C语言程序段如下
\begin{lstlisting}[language=C]
    struct {
        int a;
        char b;
        short c;
    }record;
    record.a = 273;
\end{lstlisting}
    若record变量的首地址为0xC008地址0xC008中的内容及record.c的地址分别是()
    A.0x00, 0xC00D\qquad B.0x00,0xC00E\qquad C.0x11,0xC00D \qquad D.0x11,0xC00E 

    \item \bt 有如下C语言序段:
\begin{lstlisting}[language=C]
    short si = -32767;
    unsigned short usi = si;
\end{lstlisting}
    这执行上述两条语句后,usi的值是\_\_\_\_ 

    \item 某计算机字长为32位,按字节编址,采用小端方式存放数据,假定有一个$double$型变量,其机器数表示
    为1122\ 3344\ 5566\ 7788H,存放在以0000\ 8040H开始的连续存储单元中,则存储单元0000\ 8046H中存储的是(   )\\
    A.22H\qquad B.33H\qquad C.77H\qquad D.66H 

    \item 在规格化浮点运算中,若浮点数$2^5\times1.10101$,其中尾数为补码表示,则该数(   ) \\
    A.不需要规格化\qquad B.需要右移规格化 \\
    C.需将尾数左移一位规格化\qquad D.需将尾数左移二位规格化 

    \item 某浮点机,采用规格化浮点数表示,阶码用移码表示(最高位表示符号位),尾数用原码表示,下列(   )表示不是规格化浮点数 \\
    A.1111111, 1.10000...000 \qquad B.0011111, 1.0111...01 \\
    B.1000001, 0.11111...111 \qquad D.0111111, 0.100000000 

    \item 下列关于对阶操作说法正确的是(   ) \\
    A. 在浮点数加减运算对阶操作中,若阶码减少,则尾数左移 \\
    B. 在浮点数加减运算对阶操作中,若阶码增大,则尾数右移;若阶码减少,则尾数左移 \\
    C. 在浮点数加减运算对阶操作中,若阶码增大,则尾数右移 \\
    D. 以上说法都不对 

    \item 在$IEEE\ 754$标准中,它所能表示的最小规格化负数为(    )

    \item 采用规格化的浮点数最主要是为了(   ) \\
    A.增加数据的表示范围\qquad B.方便浮点运算\\
    C.防止运算时数据溢出\qquad D.增加数据的表示精度 

    \item 设浮点数共12位,其中阶码以4位补码表示(1位符号),尾数用8位补码表示(1为符号).则该规格化浮点数
    所能表示的最大正数为(    ) 

    \item 若浮点数的尾数用补码表示,则下列(   )中的尾数是规格化形式 \\
    A.1.11000\qquad B.0.01110\qquad C.0.01010\qquad D.1.00010 

    \item 设浮点数的基数为4,尾数用原码表示,则以下(   )是规格化的数 \\
    A.1.001101\qquad B.0.001101\qquad C.1.011011\qquad D.0.000010 

    \item 下列关于舍入的说法,正确的是(多选)(   )
    \begin{enumerate}
        \item [(1)] 不仅仅只有浮点数需要舍入,定点数在运算时也可能舍入 
        \item [(2)] 在浮点数舍入中,只有左规格化时可能舍入
        \item [(3)] 在浮点数舍入中,只有右规格化时可能舍入
        \item [(4)] 在浮点数舍入中,左,右规格化时都可能舍入
        \item [(5)] 舍入不一定能产生误差
    \end{enumerate}

    \item \bt 假定变量$i,f,d$的数据类型分别是$int,float,double$(int用补码表示,其余用IEEE\ 754浮点
    数格式),已知$i=785,f=1.5678E3,d=1.5E100$,若在$32$位机器中执行下列关系表达式,则结果为真的是(多选)(   )
    \begin{enumerate}
        \item [(1)] $i==(int)(float)i$ 
        \item [(2)] $f==(float)(int)f$ 
        \item [(3)] $f==(float)(double)f$
        \item [(4)] $(d+f)-d==f$
    \end{enumerate}

    \item \bt $flota$类型数据通常用IEEE\ 754单精度格式表示,若编译器将$float$型变量$x$分配在一个
    32位浮点寄存器$FR1$中,且$x=-8.25$则$FR1$中的内容是\_\_\_\_ 

    \item \bt 下列关于浮点数加减运算中,正确的是(多选)(    )
    \begin{enumerate}
        \item [(1)] 对阶操作不会引起阶码上溢或下溢 
        \item [(2)] 右规和尾数舍入都可以引起阶码上溢 
        \item [(3)] 左规时可能引起阶码下溢 
        \item [(4)] 尾数溢出时结果不一定溢出 
    \end{enumerate}

    \item \bt 假定用若干$2K\times 4$的芯片组成一个$8K\times 8$的存储器,则地址081FH所在芯片的
    最小地址是(    ) \\
    A.0000H\qquad B.0600H\qquad C.0700H\qquad D.0800H 

    \item \bt 某计算机存储器按字节编址,主存地址空间大小为$64MB$,现用$4M\times 8$位的RAM芯片组成
    32MB的主存储器,则存储器地址寄存器$MAR$的位数至少是\_\_\_\_ 

    \item \bt 某磁盘的转速为$10000$转/分,平均寻道时间是$6ms$,磁盘传输速率是$20MB/s$磁盘控制器延迟
    为$0.2ms$,读取一个$4KB$的扇区所需要的平均时间约为(   ) \\
    A.$9ms$\qquad B.$9.4ms$\qquad C.$12ms$\qquad D.$12.4ms$

    \item \bt 假设主存地址为32位,按字节编址,主存和Cache之间采用直接映射方式,主存块大小为4个字,每个字32位,
    采用回写方式,则能存放4K字数据的Cache总容量的位数至少是(   ) \\
    A.146K\qquad B.147K\qquad C.148K\qquad D.158K 

    \item \bl 一个计算机系统采用32位单字长指令,地址码12位,若定义了250条二地址指令,则还可以有(   )单地址指令. \\
    A.4K\qquad B.8K\qquad C.16K\qquad D.24K 

    \item \bt 下列选项中,属于指令集体系结构(ISA)规定的内容是(多选)(    )
    \begin{enumerate}
        \item [(1)] 指令字格式和指令类型 
        \item [(2)] CPU的时钟周期 
        \item [(3)] 同样寄存器个数和位数 
        \item [(4)] 加法器的进位方式
    \end{enumerate}

    \item \bt 设计某指令系统时,假设采用16位定长指令格式,操作码使用拓展编码方式,地址码为6位,包括零
    地址,一地址和二地址三种指令.若二地址指令有12条,一地址指令有254条,则零地址指令的条数最多为(   )\\
    A.0\qquad B.2\qquad C.64\qquad D.128

    \item 指令系统中采用不同寻址方式的目的是(   )\\
    A.提供拓展操作码的可能性并降低译码难度 \\
    B.可缩短指令字长,托大寻址空间,提高编程的灵活性 \\
    C.实现程序控制 \\
    D.三者都正确 

    \item 简化地址结构的基本方法是尽量采用(   ) \\
    A.寄存器寻址\qquad B.隐含寻址\qquad C.直接寻址\qquad D.间接寻址 

    \item 在多道程序设计中,最重要的寻址方式是(   ) \\
    A.相对寻址\qquad B.间接寻址\qquad C.立即寻址\qquad D.按内容寻址
    
    \item 设相对寻址的转移指令占3B,第一字节为操作码,第二、三字节为相对位移量(补码 表示),
    而且数据在存储器中采用以低字节为字地址的存放方式。每当CPU从存储器取 出一字节时,
    即自动完成(PC)+1$\rightarrow$PC。若PC的当前值为240 (十进制),要求转移到 290 (十进制),
    则转移指令的第二、三字节的机器代码是();若PC的当前值为240 (十进制),要求转移到200 (十进制),
    则转移指令的第二、三字节的机器代码是()。 \\
    A.2FH,FFH \qquad B.D5H,00H\qquad C.D5H,FFH\qquad D.2FH,00H

    \item 】某计算机有16个通用寄存器,采用32位定长指令字,操作码字段(含寻址方式位)为8位,Store指令的源操作数和目的操作数分别采用寄存器直接寻址和 基址寻址方式。
    若基址寄存器可使用任意一个通用寄存器,且偏移量用补码表示,则Store 指令中偏移量的取值范围是(   ) \\
    A.$-32768\sim +32767$\qquad B.$-32767\sim +32768$ \\
    B.$=65536\sim +65535$\qquad D.$-65535\sim +65536$ 

    \item 按字节编址的计算机中,某double型数组A的首地址为2000H,使用变址寻址和循环结构访问数组A,
    保存数组下标的变址寄存器的初值为0,每次循环取一个数组元素,其偏移地址为变址值乘以
    sizeof(double),取完后变址寄存器的内容自动加1。若某次循环所取元素的地址为2100H,
    则进入该次循环时变址寄存器的内容是(   ) \\
    A.25\qquad B.32\qquad C.64\qquad D.100 

\end{enumerate}

\section{综合题}
\ifx\allfiles\undefined
\end{document}
\fi