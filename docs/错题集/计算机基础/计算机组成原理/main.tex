\ifx\allfiles\undefined
\documentclass[12pt, a4paper, oneside, UTF8]{ctexbook}
\def\path{../config}
\input{../config/_config}
\begin{document}
% \input{../config/cover}
\else
\fi
\chapter{计算机组成原理}

\section{选择题}
\begin{enumerate}
    \item 冯$\cdot$诺依曼机的基本工作方式是(  ) 
    \begin{choices}[2]
    \task 控制流驱动方式 \task 多指令多数据流方式
    \task 微程序控制器 \task 数据流驱动方式
    \end{choices}
    
    \item \bt 将高级语言源程序转换为机器级目标文件的程序是(   ) 
    \begin{choices}
        \task 汇编程序 
        \task 链接程序 
        \task 编译程序 
        \task 解释程序
    \end{choices}

    \item 在计算机中,CPU的CPI与下列(   )因素无关.
    \begin{choices}
        \task 时钟频率 \task 系统结构 
        \task 指令集 \task 计算机组织 
    \end{choices}


    \item 某计算机主频为$1GHz$,程序P运行过程中,共执行了$10000$条指令,其中,$80\%$的指令执行平均
    需要1个始终周期,$20\%$的指令执行平均需10个时钟周期.程序P的平均CPI和CPU执行时间分别是(   ) 
    \begin{choices}
        \task $2.8,28\mu s$ 
        \task $28,28\mu s$
        \task $2.8,28ms$
        \task $28,28ms$ 
    \end{choices}
    

    \item 若$X$为负数,则由$[X]_{\text{补}}$求$[-X]_{\text{补}}$是将(   )
    \begin{choices}[1]
        \task $[X]_{\text{补}}$各值保持不变
        \task $[X]_{\text{补}}$符号位变反,其他位不变
        \task $[X]_{\text{补}}$除符号位外,其余位取反,末尾加一
        \task $[X]_{\text{补}}$连同符号位一起变反,末尾加一
    \end{choices}


    \item 对于相同位数(设N位,不考虑符号位)的二进制补码小数和十进制小数,二进制小数能表示的数的个数/十进制
    小说所能表示的个数为(  )
    \begin{choices}
        \task $(0.2)^{N}$
        \task $(0.2)^{N-1}$
        \task $(0.02)^{N}$
        \task $(0.02)^{N-1}$ 
    \end{choices}
    

    \item 设$x$为真值,$x^{*}$为其绝对值,满足$[-x^*]_{\text{补}}=[-x]_{\text{补}}$当且仅当x为(   ) 
    \begin{choices}
        \task 任意数
        \task 正数 
        \task 负数 
        \task 以上均不正确
    \end{choices}
    

    \item ALU作为运算器的核心部件,其属于(   ) 
    \begin{choices}
        \task 时序逻辑电路
        \task 组合逻辑电路
        \task 控制器 
        \task 寄存器
    \end{choices}
    

    \item \bl 加法器中每位的进位信号由(   )组成
    \begin{choices}
        \task $X_i\oplus Y_i$
        \task $X_iY_i$
        \task $X_iY_iC_i$
        \task $X_i+Y_i+C_i$
    \end{choices}
    

    \item 一个8位寄存器内的数值为\underline{1100\ 1010}进位标志位寄存器C为0,若将此8位寄存器循环左移
    1位后,则该寄存器和标志寄存器的值分别为(   ) 
    \begin{choices}
        \task 1001\ 0100, 1
        \task 1001\ 0101, 0
        \task 1001\ 0101, 1
        \task 1001\ 0100, 0
    \end{choices}
    

    \item 设机器数字长8位(含一位符号位),若机器数为$BAH$为原码,算术左移1和算术右移1位分别得(   ) 
    \begin{choices}
        \task $F4H,EDH$
        \task $B4H,6DH$
        \task $74H,DDH$
        \task $B5H,EDH$
    \end{choices}
    

    \item 关于模4补码,下列说法中正确的是(   ) 
    \begin{choices}[1]
        \task 模4补码和模2补码不同,它不容易检查乘除运算中的溢出问题
        \task 每个模4补码存储时只需要存储一位符号位
        \task 存储每个模4补码需要存储两个符号位
        \task 模4补码,在算术与逻辑部件中为一个符号位
    \end{choices}


    \item 在原码一位乘法中,(   ) 
    \begin{choices}[1]
        \task 符号位参与运算
        \task 符号位不参与运算
        \task 符号位参与运算,并根据运算结果改变结果中的符号位
        \task 符号位不参与运算,并根据运算结果改变结果中的符号位
    \end{choices}


    \item \bl 某计算机字长为8位,CPU中有一个8位加法器.已知无符号数$x=69,y=38$,如果在该加法器中计算x-y,则加法
    器的两个输入端入端信息和低位进位信息分别是() 
    \begin{choices}[2]
        \task 0100\ 0101,0010\ 0110, 0
        \task 0100\ 0101,1101\ 1001, 1
        \task 0100\ 0101,1101\ 1010, 0
        \task 0100\ 0101,1101\ 1010, 1
    \end{choices}


    \item \bt 某计算机存储器按字节编制,采用小端方式存放数据.假定编译器规定int型和short型长度分别为32位和16位
    并且数据按边界对齐存储.某C语言程序段如下
    \begin{center}
    \begin{lstlisting}[language=C]
    struct {
        int a;
        char b;
        short c;
    }record;
    record.a = 273;
    \end{lstlisting}
    \end{center}
    若record变量的首地址为0xC008地址0xC008中的内容及record.c的地址分别是()
    \begin{choices}
        \task 0x00, 0xC00D
        \task 0x00,0xC00E
        \task 0x11,0xC00D
        \task 0x11,0xC00E
    \end{choices}


    \item \bt 有如下C语言序段:
    \begin{lstlisting}[language=C]
    short si = -32767;
    unsigned short usi = si;
    \end{lstlisting}
    这执行上述两条语句后,usi的值是\_\_\_\_ 

    \item 某计算机字长为32位,按字节编址,采用小端方式存放数据,假定有一个$double$型变量,其机器数表示
    为1122\ 3344\ 5566\ 7788H,存放在以0000\ 8040H开始的连续存储单元中,则存储单元0000\ 8046H中存储的是(   )
    \begin{choices}
        \task 22H 
        \task 33H 
        \task 77H 
        \task 66H 
    \end{choices}
    

    \item 在规格化浮点运算中,若浮点数$2^5\times1.10101$,其中尾数为补码表示,则该数(   ) 
    \begin{choices}[2]
        \task 不需要规格化
        \task 需要右移规格化
        \task 需将尾数左移一位规格化
        \task 需将尾数左移二位规格化
    \end{choices}


    \item 某浮点机,采用规格化浮点数表示,阶码用移码表示(最高位表示符号位),尾数用原码表示,下列(   )表示不是规格化浮点数 
    \begin{choices}[2]
        \task 1111111, 1.10000...000
        \task 0011111, 1.0111...01
        \task 1000001, 0.11111...111
        \task 0111111, 0.100000000 
    \end{choices}


    \item 下列关于对阶操作说法正确的是(   ) 
    \begin{choices}[1]
        \task 在浮点数加减运算对阶操作中,若阶码减少,则尾数左移
        \task 在浮点数加减运算对阶操作中,若阶码增大,则尾数右移;若阶码减少,则尾数左移
        \task 在浮点数加减运算对阶操作中,若阶码增大,则尾数右移
        \task 以上说法都不对
    \end{choices}


    \item 在$IEEE\ 754$标准中,它所能表示的最小规格化负数为(    )

    \item 采用规格化的浮点数最主要是为了(   ) 
    \begin{choices}[2]
        \task 增加数据的表示范围
        \task 方便浮点运算
        \task 防止运算时数据溢出
        \task 增加数据的表示精度 
    \end{choices}


    \item 设浮点数共12位,其中阶码以4位补码表示(1位符号),尾数用8位补码表示(1为符号).则该规格化浮点数
    所能表示的最大正数为(    ) 

    \item 若浮点数的尾数用补码表示,则下列(   )中的尾数是规格化形式 
    \begin{choices}
        \task 1.11000
        \task 0.01110
        \task 0.01010
        \task 1.00010 
    \end{choices}
    

    \item 设浮点数的基数为4,尾数用原码表示,则以下(   )是规格化的数 
    \begin{choices}
        \task 1.001101
        \task 0.001101
        \task 1.011011
        \task 0.000010 
    \end{choices}
    

    \item 下列关于舍入的说法,正确的是(多选)(   )
    \begin{enumerate}
        \item [(1)] 不仅仅只有浮点数需要舍入,定点数在运算时也可能舍入 
        \item [(2)] 在浮点数舍入中,只有左规格化时可能舍入
        \item [(3)] 在浮点数舍入中,只有右规格化时可能舍入
        \item [(4)] 在浮点数舍入中,左,右规格化时都可能舍入
        \item [(5)] 舍入不一定能产生误差
    \end{enumerate}

    \item \bt 假定变量$i,f,d$的数据类型分别是$int,float,double$(int用补码表示,其余用IEEE\ 754浮点
    数格式),已知$i=785,f=1.5678E3,d=1.5E100$,若在$32$位机器中执行下列关系表达式,则结果为真的是(多选)(   )
    \begin{enumerate}
        \item [(1)] $i==(int)(float)i$ 
        \item [(2)] $f==(float)(int)f$ 
        \item [(3)] $f==(float)(double)f$
        \item [(4)] $(d+f)-d==f$
    \end{enumerate}

    \item \bt $flota$类型数据通常用IEEE\ 754单精度格式表示,若编译器将$float$型变量$x$分配在一个
    32位浮点寄存器$FR1$中,且$x=-8.25$则$FR1$中的内容是\_\_\_\_ 

    \item \bt 下列关于浮点数加减运算中,正确的是(多选)(    )
    \begin{enumerate}
        \item [(1)] 对阶操作不会引起阶码上溢或下溢 
        \item [(2)] 右规和尾数舍入都可以引起阶码上溢 
        \item [(3)] 左规时可能引起阶码下溢 
        \item [(4)] 尾数溢出时结果不一定溢出 
    \end{enumerate}

    \item \bt 假定用若干$2K\times 4$的芯片组成一个$8K\times 8$的存储器,则地址081FH所在芯片的
    最小地址是(    ) 
    \begin{choices}
        \task 0000H
        \task 0600H
        \task 0700H
        \task 0800H
    \end{choices}
    

    \item \bt 某计算机存储器按字节编址,主存地址空间大小为$64MB$,现用$4M\times 8$位的RAM芯片组成
    32MB的主存储器,则存储器地址寄存器$MAR$的位数至少是\_\_\_\_ 

    \item \bt 某磁盘的转速为$10000$转/分,平均寻道时间是$6ms$,磁盘传输速率是$20MB/s$磁盘控制器延迟
    为$0.2ms$,读取一个$4KB$的扇区所需要的平均时间约为(   ) 
    \begin{choices}
        \task $9ms$
        \task $9.4ms$
        \task $12ms$
        \task $12.4ms$
    \end{choices}
    

    \item \bt 假设主存地址为32位,按字节编址,主存和Cache之间采用直接映射方式,主存块大小为4个字,每个字32位,
    采用回写方式,则能存放4K字数据的Cache总容量的位数至少是(   ) \\
    A.146K\qquad B.147K\qquad C.148K\qquad D.158K 

    \item \bl 一个计算机系统采用32位单字长指令,地址码12位,若定义了250条二地址指令,则还可以有(   )单地址指令. \\
    A.4K\qquad B.8K\qquad C.16K\qquad D.24K 

    \item \bt 下列选项中,属于指令集体系结构(ISA)规定的内容是(多选)(    )
    \begin{enumerate}
        \item [(1)] 指令字格式和指令类型 
        \item [(2)] CPU的时钟周期 
        \item [(3)] 同样寄存器个数和位数 
        \item [(4)] 加法器的进位方式
    \end{enumerate}

    \item \bt 设计某指令系统时,假设采用16位定长指令格式,操作码使用拓展编码方式,地址码为6位,包括零
    地址,一地址和二地址三种指令.若二地址指令有12条,一地址指令有254条,则零地址指令的条数最多为(   )\\
    A.0\qquad B.2\qquad C.64\qquad D.128

    \item 指令系统中采用不同寻址方式的目的是(   )\\
    A.提供拓展操作码的可能性并降低译码难度 \\
    B.可缩短指令字长,托大寻址空间,提高编程的灵活性 \\
    C.实现程序控制 \\
    D.三者都正确 

    \item 简化地址结构的基本方法是尽量采用(   ) \\
    A.寄存器寻址\qquad B.隐含寻址\qquad C.直接寻址\qquad D.间接寻址 

    \item 在多道程序设计中,最重要的寻址方式是(   ) \\
    A.相对寻址\qquad B.间接寻址\qquad C.立即寻址\qquad D.按内容寻址
    
    \item 设相对寻址的转移指令占3B,第一字节为操作码,第二、三字节为相对位移量(补码 表示),
    而且数据在存储器中采用以低字节为字地址的存放方式。每当CPU从存储器取 出一字节时,
    即自动完成(PC)+1$\rightarrow$PC。若PC的当前值为240 (十进制),要求转移到 290 (十进制),
    则转移指令的第二、三字节的机器代码是();若PC的当前值为240 (十进制),要求转移到200 (十进制),
    则转移指令的第二、三字节的机器代码是().
    \begin{choices}
        \task 2FH,FFH 
        \task D5H,00H 
        \task D5H,FFH 
        \task 2FH,00H
    \end{choices}

    \item 某计算机有16个通用寄存器,采用32位定长指令字,操作码字段(含寻址方式位)为8位,Store指令的源操作数和目的操作数分别采用寄存器直接寻址和 基址寻址方式。
    若基址寄存器可使用任意一个通用寄存器,且偏移量用补码表示,则Store 指令中偏移量的取值范围是(   ) 
    \begin{choices}[2]
        \task $-32768\sim +32767$ \task $-32767\sim +32768$ 
        \task $-65536\sim +65535$ \task $-65535\sim +65536$ 
    \end{choices}


    \item 按字节编址的计算机中,某double型数组A的首地址为2000H,使用变址寻址和循环结构访问数组A,
    保存数组下标的变址寄存器的初值为0,每次循环取一个数组元素,其偏移地址为变址值乘以
    sizeof(double),取完后变址寄存器的内容自动加1。若某次循环所取元素的地址为2100H,
    则进入该次循环时变址寄存器的内容是(   )
    \begin{choices}
    \task 25 \task 32 \task 64 \task 100
    \end{choices} 

\end{enumerate}

\section{综合题}
\ifx\allfiles\undefined
\end{document}
\fi