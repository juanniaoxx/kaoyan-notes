\ifx\allfiles\undefined
\documentclass[12pt, a4paper, oneside, UTF8]{ctexbook}
\def\path{../config}
\input{../config/_config}
\begin{document}
% \input{../config/cover}
\else
\fi
\chapter{数据结构}
\section{选择题}
\begin{enumerate}
    \item \bt 下列程序段的时间复杂度是\_\_\_\_ 
    \begin{lstlisting}[language=C]
int sum = 0;
    for(int i = 1; i < n; i *= 2)
        for(int j = 0; j < i; j++)
            sum++;
    \end{lstlisting}

    \answer{
        \bs {
        假设第t次时$2^t\geq n$,此时$sum$执行的总次数为 
        $$
        1 + 2 + 4 + \ldots + 2^t = \frac{1-2^t}{1-2}=2^t - 1
        $$
        又因为$t=\log_2{n}$故而总的计算执行次数为$n-1\sim O(n)$
    }
    }

    \item 关于线性表的顺序存储和链式存储结构的描述中,正确的是(    ) 
    \begin{enumerate}
        \item [(1)] 线性表的顺序结构优于其链式存储结构
        \item [(2)] 链式存储结构比顺序存储结构能更方便地表示各种逻辑结构
        \item [(3)] 若频繁使用插入和删除操作,则顺序存储结构更优于链式存储结构
        \item [(4)] 顺序存储结构和链式存储结构都可以进行顺序存取 
    \end{enumerate}
    \begin{choices}
        \task 1,2,3
        \task 2,4
        \task 2,3
        \task 3,4
    \end{choices}
    \answer{
        \bs {
        选B 
        }
    }
    \item 对于一个头指针为$head$的带头结点的单链表,判断该表为空表的条件是(   ),对于不带头结点
    的单链表,判断空表的条件是(   ) 
    \begin{choices}[2]
        \task $head == NULL$ 
        \task $head\rightarrow next == NULL$ 
        \task $head\rightarrow next == head$ 
        \task $head \neq NULL$
    \end{choices}

    \answer{
        \bs{
            B,A 
        }
    }
    \item 一个链表最常用的操作为在末尾插入结点和删除节点,则选用(   )最节省时间. 
    \begin{choices}[2]
        \task 带头结点的双循环链表
        \task 单循环列表
        \task 带尾结点的单循环链表
        \task 单链表
    \end{choices}

    \answer{
        \bs {
            选A,可以注意分析时间复杂度.容易得到 \\
            对于A选项,分别为$O(1),O(1)$;对于B,C,D选项,分别为$O(n),O(n)$
        }
    }
    \item 设对$n(n>1)$元素的线性表运算只有4种,删除第一个元素,删除最后一个元素,在第一个元素之前插入
    一个元素,在最后一个元素之后插入一个元素,则最好使用(    ) 
    \begin{choices}[1]
        \task 只有尾结点指针没有头结点指针的循环单链表
        \task 只有尾结点指针没有头结点指针的非循环双链表
        \task 只有头结点指针没有尾结点指针的循环双链表
        \task 既有头结点有又有尾结点的循环单链表
    \end{choices}

    \answer{
        \bs {
            和上题一样逐一分析时间复杂度,选C.此时四种操作均可以达到$O(1)$的时间复杂度.
        }
    }
    \item 假定利用数组 $a[n]$ 存储一个栈,初始栈顶指针 $top==-1$,则元素x进栈的操作为() 
    \begin{choices}
        \task $a[--top] = x$ 
        \task $a[top--] = x$
        \task $a[++top] = x$
        \task $a[top++] = x$
    \end{choices}

    \answer{
        \bs {
            选C \\
            用数组模拟栈,具体的操作完全没比较记忆.毕竟$top=0$或者$top=-1$是完全不同的,掌握原理
            才是根本. \\
            考虑本题,由于$top=-1$,每次进栈前,应该先让$top+=1$在执行赋值操作,故应该为$top[++top]=x$;出栈操作为
            $top--$;
        }

        \begin{remark}[区分$++x$和$x++$]
            $++x$不会产生临时的副本,而是直接将$x+=1$的值返回给调用者; \\
            $x++$则会产生临时的$x$值,并将$x$的值返回给调用者后,将$x+=1$;
        \end{remark}
    }
    \item 和顺序栈相比,链栈有一个比较明显的优势,即() 
    \begin{choices}[2]
        \task 通常不会出现栈满的情况 
        \task 通常不会出现栈空的情况 
        \task 插入操作更容易实现 
        \task 删除操作更容易实现 
    \end{choices}

    \answer{
        \bs {
            选A \\
            顺序栈用数组实现,而数字的大小是指定的(不考虑动态申请数组空间的情况),而链栈用链表实现
            申请结点空间较为容易.故后者不容易出现栈满情况.
        }
    }
    \item 链栈(不带头结点)执行Pop操作,并将出栈元素存在x中,应该执行() 
    \begin{choices}[2]
        \task $x=top;top=top\rightarrow next$ 
        \task $x=top\rightarrow data$ 
        \task $top=top\rightarrow next;x=top\rightarrow data$
        \task $x=top\rightarrow data;top=top\rightarrow next$ 
    \end{choices}

    \answer{
        \bs {
            选D \\
            向将栈中的数据保存进$x$中,再将$top$指针后移(惰性删除,并不直接释放空间).
        }
    }
    \item 三个不同元素进栈,能够得到()不同的出栈序列 
    
    \answer{
        \bs {
            5个 \\
            对于n不大的情况,可以直接穷举.假设三个元素为$a,b,c$则穷举出栈序列即可 \\
            (1)$a,b,c$\qquad (2)$a,c,b$\qquad (3)$b,a,c$\\
            (4)$b,c,a$\qquad (5)$c,b,a$
        }

        \begin{remark}[求n个不同元素的出栈序列的个数]
            $$
            N=\frac{1}{n+1}C_{2n}^{n} 
            $$
            比如上题就可以用公式计算 
            $$
            \frac{1}{4}\cdot\frac{6*5*4}{3*2*1} = 5
            $$
        \end{remark}
    }
    \item 一个栈的输入序列为$1,2,\ldots,n$输出序列的第一个元素为i,则第j个输出元素是() 
    \begin{choices}
        \task 不确定
        \task n - i 
        \task n - i - 1
        \task n - i + 1
    \end{choices}

    \answer{
        \bs {
            选A,不确定
        }
    }

    \item 设栈的初始状态为空,当字符序列 \underline{n1\_}作为栈的输入时,输出长度为3,且可用做C语言
    标识符的序列有()个
    \begin{choices}
        \task 3
        \task 4
        \task 5
        \task 6
    \end{choices}
    \answer{
        \bs {
            答案选A,3个 \\
            C语言中变量标识符(变量名)只能以$\_$或者字母开头不能以数组开头.故只有3中可能的输出即\\
            $\_1n$ \qquad $n1\_$ \qquad $n\_ 1$
        }
    }
    \item 设有一个顺序共享栈Share[0:n-1],其中第一个栈顶指针top1的初始值为-1,第二个栈顶指针top2的初始值
    为n,则判断共享栈满的条件是() 
    \begin{choices}[2]
        \task $top2-top1\ ==\ 1$
        \task $top1-top2\ ==\ 1$ 
        \task $top1\ ==\ top2$ 
        \task 以上对不对
    \end{choices}

    \answer{
        \bs {
            选A \\
            第一个栈从$0\ldots,top1$;第二个栈从$top2,\ldots,n-1$只要两个栈指针相遇即$top1+1==top2$的时候
            共享栈就满了,此时$top2-top1==1$
        }
    }
    \item \bl 若元素\underline{a,b,c,d,e,f}依次进栈,允许进栈,出栈交替进行,但不允许连续3次进栈,退栈
    操作,不可能得到的出栈序列是() 
    \begin{choices}
        \task \underline{dcebfa}
        \task \underline{cbdaef}
        \task \underline{bcaefd}
        \task \underline{afedcb} 
    \end{choices}

    \answer{
        \bs {
            没有技巧,枚举的时候要考虑全面即可. 选D
        }
    }

    \item \bl 一个栈的入栈序列为\underline{$1,2,3\ldots,n$}出栈序列为$P_1,P_2,\ldots,P_n$.若$P_2=3$则$P_3$可能 
    的取值的个数是() 
    \begin{choices}
        \task n-3
        \task n-2
        \task n-1
        \task 无法确定 
    \end{choices}

    \answer{
        \bs {
            除$P_2=3$外其余全部数,即$n-1$选C
        }
    }
    \item \bl 若栈S1中保存整数,栈S2中保存运算符,函数F()依次执行如下各步操作: 
    \begin{enumerate}[label= (\arabic*)]
        \item 从S1中依次弹出两个操作数a和b
        \item 从S2中弹出一个运算符op
        \item 执行相应的运算b\ op\ a 
        \item 将运算结果压入S1中 
    \end{enumerate}
    假定S1中的操作数一次是\underline{5,8,3,2(2在栈顶)},S2中的运算符依次是\underline{*,-,+(栈顶)}.调用
    3次F()后,S1栈顶保存的值是() 
    \begin{choices}
        \task -15
        \task 15
        \task -20
        \task 20
    \end{choices}

    \answer{
        \bs {
            选B,模拟的时候注意题目要求$b\ op\ a$,$b$是第二次弹出的,$a$是第一次弹出的.
        }
    }
    \item 循环队列存储在数组$A[0\ldots n]$中,其中$rear$为队尾指针,$front$为队首指针.则入队时的操作为\_\_\_;
    出队时的操作为\_\_\_\_;判断队空的操作为\_\_\_;判断队满的操作为\_\_\_

    \answer{
        \bs {
            入队:$rear=(rear+1)\% (n+1); A[rear]=x$ \\
            出队:$front=(front+1)\%(n+1)$ \\
            判空:$rear=front$ \\
            判满:$(rear+1)\%(n+1)==front$
        }
    }
    \item 用链式存储方法的队列进行删除操作时需要() 
    \begin{choices}[2]
        \task 仅修改头指针
        \task 仅修改尾指针
        \task 头尾指针都要修改
        \task 头尾指针可能都要修改 
    \end{choices}

    \answer{
        \bs {
            选D \\
            如果队列中元素不止一个,仅修改头指针;但如果队列中的元素仅一个的时候,就需要修改头指针和尾指针即$rear==front$
        }
    }

    \item 假设循环单链表表示的队列长度为n,队头固定在链表尾,若只设置头指针,则进队操作的时间复杂度为() 
    \begin{choices}
        \task $O(n) $ \task $O(1)$ \task $O(n^2)$ \task $O(n\log_{2}{n})$
    \end{choices}

    \answer{
        \bs {
            选A \\
            插入即在链头插入,此时时间复杂度是$O(1)$但为了保持循环单链表的性质,需要找到链尾(队头)元素,此时需要$O(n)$的时间复杂度.
        }
    }
    \item \bl 已知循环队列存储在一维数组$A[0\ldots n-1]$中,且队列非空时$front$和$rear$分别指向队头元素
    和队尾元素.若初始队列为空,且要求第一个进入队列的元素存储在$A[0]$处,则初始时$front$和$rear$的值分别是() 
    \begin{choices}
        \task 0,0 \task 0, n-1 \task n-1,0 \task n-1,n-1
    \end{choices}

    \answer{
        \bs {
            选B
        }
    }
    \item 循环队列放在一维数组$A[0\ldots M-1]$中, end1指向对首元素,end2指向队尾元素的后一个位置.假设
    队列两端均可进行入队与出队操作,队列中最多能容纳M-1个元素.初始时为空,下列判断队满和队空的条件中,正确的是() 
    \begin{choices}[1]
        \task 队空:$end1\ ==\ end2$ 队满: $end1\ ==\ (end2+1)\ mod\ M$ 
        \task 队空:$end1\ ==\ end2$ 队满: $end2\ ==\ (end1+1)\ mod\ (M-1)$
        \task 对空:$end2\ ==\ (end1+1)\ mod\ M$ 队满: $end1\ ==\ (end2+1)\ mod M$
        \task 对空:$end1\ ==\ (end2+1)\ mod\ M$ 队满: $end2\ ==\ (end1+1)\ mod (M-1)$
    \end{choices}

    \answer{
        \bs {
            选A
        }
    }
    \item \bl 已知操作符包含$+,-,*,/,(,)$.将中缀表达式$a+b-a*((c+d)/e-f)+g$转换为等价的后缀表达式(逆波兰表示法),
    用栈来实现.初始时栈为空,转换过程中栈中至多保存()个操作符. 

    \answer{
        \bs {
            5个 \\
            可以用栈直接做,也可以转化为二叉表达式树做(我感觉后者更好);当然前者也不能不会.
        }
    }

    \item \bt 有一个$n\times n$的对称矩阵$A$,将其下三角部分按行存放在一维数组B中,而$A[0][0]$存放在$B[0]$中,则
    第$i+1$行对角元素$A[i][i]$存放在B中的()处 
    \begin{choices}
        \task (i+3)i/2 
        \task (i+1)i/2
        \task (2n-i+1)i/2
        \task (2n-i-1)i/2 
    \end{choices}

    \answer{
        \bs {
            选A
        }
    }
    \item \bl 由一个100阶的三对角矩阵M,其元素$m_{i,j}(1\leq i, j\leq 100)$按行优先依次压入下标从0开始的一维
    数组N中.元素$m_{30,30}$在N中的下标是() 

    \answer{
        \bs {
            (1) 可以记公式$k=2i+j-3$ \\
            (2) 把三对角线矩阵画出来,观察. 第一个行元素为两个,在$m_{30,30}$所在行之前有$28$行这些行有3个元素;
            本行在$m_{30,30}$之前仅有$m_{30,29}$故$2+28\times+3+2 - 1 = 87$
        }
    }
    \item \bt 在KMP算法中,串\underline{ababaaababaa}的PM数组,Next数组,Nextval数组分别为? 
    \answer{
        \bs {
            (1) PM数组结果 \underline{001231123456} \\
            (2) Next(1)数组 \underline{-100123112345} \\
            (3) Next(2)数组 \underline{011234223456} \\
            (4) Nextval数组 \underline{010104210104}
        }
    }
    \item \bl 设主串$T=abaabaabcabaabc$模式串$S=abaabc$采用KMP算法进行模式匹配,到匹配成功为止,在匹配过程中进行的
    单个字符间的比较次数是()
    
    \answer{
        \bs {
            10次
        }
    }
    \item 树的路径长度是从树根到每个结点的路径长度的(   ) 
    \begin{choices}
        \task 总和
        \task 最小值
        \task 最大值
        \task 平均值
    \end{choices}

    \answer{
        \bs {
            树的路径长度:从树根到每个结点的路径长度的总和 \\
            树的带权路径长度(WPL):\\
            树中所有叶子结点的权值X该叶子到根的路径长度的总和 \\
            二者的区别在于,前者计算内部节点与叶子结点;而后者仅计算叶结点.
        }
    }
    \item (判断正误) 
    \begin{enumerate}
        \item [(1)] 度为2的有序树就是二叉树
        \item [(2)] 结点按完全二叉树层序编号的二叉树中,第$i$个结点的左孩子编号为$2i$ 
    \end{enumerate}
    
    \answer{
        \bs {
            错;\ 这二者的区别在于,对于二叉树,若一个结点仅有一个孩子,这个子结点是左孩子还是有孩子是
            确定的;而对于度为2的有序树,这个孩子是左孩子还是右孩子是无所谓的 \\
            错误;\ 左孩子不一定存在.
        }
    }

    \item 具有10个叶结点的二叉树中有(   )个度为2的结点 
    
    \answer{
        \bs {
            基本公式,对于二叉树有如下公式$n_0=n_2+1$;\\
            故$10-1=9$个度为2个结点
        }
    }
    \item 设二叉树有$2n$个结点,且$m<n$,则不可能存在(   )的结点 
    \begin{choices}
        \task n个度为0
        \task 2m个度为0
        \task 2m个度为1
        \task 2m个度为2
    \end{choices}

    \answer{
        \bs {
            选C \\
            由于$n_0=n_2-1$故一颗二叉树的总结点数目为$2n=n_1+2n_2+1$则$n_1=2(n-n_2)-1$显然
            $n_1$必须是奇数,必然不可能有$2m(\text{偶数})$个度为1的结点
        }
    }
    \item 已知一颗完全二叉树的第6层(设根为第一层)有8个结点,则完全二叉树的结点个数最少是(   ) 

    \answer{
        \bs {
            39 \\
            由于完全二叉树的特性可知,当高度为6的时候结点数目最小且前5层必然是满二叉树,故此时完全
            二叉树的结点个数最小是$2^5-1+8=39$个结点
        }
    }
    \item 一颗完全二叉树上有1001个结点,其中叶结点的个数是(    ) 

    \answer{
        \bs {
            501 \\
            解法一:\ 对于完全二叉树,若其结点数为n,则最后一个分支结点(含子结点)的序号为$x=\lfloor n/2 \rfloor$
            当$n_i>x$的时候说明该结点是叶子结点. 故本题,最后一个分支结点的序号为$\lfloor 1001/2 \rfloor=500$
            故叶结点的序号范围为$501\sim 1001$,总数为501 \\
            解法二:\ 由于$n=2n_0+n_1-1$由于完全二叉树的定义可知$n_1=0$或者$n_1=1$带入可以知$n_1=0,n_0=501$
        }
    }
    \item \bl 对于任意一颗高度为5且有10个结点的二叉树,若采用顺序存储结构保存,每个节点占1个存储单元(仅保存
    结点的数据信息),则存放该二叉树需要的存储单元数量至少是(     ) 

    \answer{
        \bs {
            31 \\
            这道题比较容易错,数字存储二叉树必须按照满二叉树存储,因为并不能事先知道那些叶结点会有; 
            故这道题的答案是$2^5-1=31$
        }
    }
    \item 在下列关于二叉树遍历的说法中,正确的是(     ) 
    \begin{choices}[1]
    \task 若有一个结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点。
    \task 若有一个结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点。
    \task 若有一个叶结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点。
    \task 若有一个叶结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点。
    \end{choices} 

    \answer{
        \bs {
            选C,这种题举反例即可,注意题设.
        }
    }
    \item 设$n,m$为一颗二叉树上的两个结点,在后序遍历时,$n$在$m$前的充分条件是(    ) 
    \begin{choices}
        \task n在m的右方 
        \task n是m的祖先
        \task n在m的左方
        \task n是m的子孙 
    \end{choices}

    \answer{
        \bs {
            选D \\
            C选项要加上二者位于同一层,才是充分条件. 
        }
    }
    \item 在二叉树中的两个结点m和n,若m是n的祖先,则使用(    )可以找到从m到n的路径 
    
    \answer{
        \bs {
            后序遍历 \\
            在遍历过程中,从根(或子树根m出发)后序遍历会先走完m的整棵子树才回溯,因此可以在访问到n时沿着递归栈或显式栈回溯,
            从而得到 m→…→n 的路径
        }
    }
    \item 若二叉树中结点的先序序列是$\ldots a\ldots b\ldots$,中序序列是$\ldots b\ldots a\ldots$则(    ) 
    \begin{choices}[1]
        \task 结点a和结点b分别在某结点的左子树和右子树中
        \task 结点b和结点a的右孩子中
        \task 结点b在结点a的左孩子中
        \task 结点a和结点b分别在某结点的两颗分非空子树中 
    \end{choices}

    \answer{
        \bs {
            选C 
        }
    }
    \item 线索二叉树是(    )结构 
    \begin{choices}
        \task 逻辑
        \task 逻辑和存储
        \task 物理
        \task 线性
    \end{choices}

    \answer{
        \bs {
            选C \\
            逻辑结构＝“是什么关系”——只关心数据之间的逻辑关系（线性、树、图等），与机器怎么存、存在哪儿无关。 \\
            物理结构＝“怎么存”——关心在内存/磁盘里到底怎么摆放（顺序表、链表、索引、散列、线索化等实现细节）。 \\
            二叉树本身是一种逻辑结构,而线索二叉树是加上前后指针后的链式结构.
        }
    }
    \item 一颗左子树为空的二叉树的先序线索化后,其中空的链域的个数是(    ) 
    \begin{choices}
        \task 不确定
        \task 0个
        \task 1个
        \task 2个
    \end{choices} 

    \answer{
        \bs {
            选D 
        }
    }
    \item 二叉树在线索化后,仍然不能有效求解的问题是(    ) 
    \begin{choices}[2]
        \task 先序线索二叉树求先序后继
        \task 中序线索二叉树求中序后继
        \task 中序线索二叉树求中序前驱
        \task 后序线索二叉树求后序后继 
    \end{choices}

    \answer{
        \bs {选D}
    }
    \item 若X是二叉中序线索树中一个有左孩子的结点,且X不为根,则X的前缀为(    ) 
    \begin{choices}[2]
        \task X的双亲
        \task X的右子树中最左节点
        \task X的左子树中最右结点
        \task X的左子树中最右的叶结点
    \end{choices}

    \answer{
        \bs {选C}
    }

    \item (   )遍历仍然需要栈的支持. 
    \begin{choices}
        \task 先序线索树
        \task 中序线索树
        \task 后序线索树 
        \task 所有线索树 
    \end{choices}

    \answer{
        \bs {
            选C \\
            后序线索树中，根的后序后继是父结点，但普通线索二叉树没有保存父指针；
            当右子树非空时，无法通过线索直接得到该后继，仍需借助栈来回溯。
        }
    }
    \item \bl 先序序列为\underline{a,b,c,d}的不同二叉树的个数是(      ) 

    \answer{
        \bs {
            14 \\
            简单来说等价于求4个元素的卡特兰数,即
            $$
            n = \frac{1}{n+1}C_{2n}^{n} = 14
            $$ 
            任何一棵n个结点的二叉树,其先序遍历序列与中序遍历序列的对应关系等价于n个元素的入栈顺序与出栈顺序的对应关系; \\
            先序遍历与入栈顺序一致 \\
            中序遍历与出栈顺序一致 \\
            故上述问题转换为入栈顺序为\underline{a,b,c,d},则出栈序列的个数是啥?
        }
    }
    \item \bl 若结点p和q在二叉树T的中序遍历序列中相邻,且p在q之前,则下列p和q的关系中,不可能的是(    )
    \begin{enumerate}
        \item [(1)] q是p的双亲 
        \item [(2)] q是p的右孩子
        \item [(3)] q是p的右兄弟
        \item [(4)] q是p的双亲的双亲
    \end{enumerate}
    \begin{choices}
        \task 1 
        \task 3
        \task 2,3
        \task 2,4
    \end{choices}

    \answer{
        \bs {选B} 
    }

    \item 利用二叉链表存储森林时,根结点的右指针是(    ) 
    \begin{choices}
        \task 指向最左兄弟 
        \task 指向最右兄弟 
        \task 一定为空
        \task 不一定为空 
    \end{choices}

    \answer{
        \bs {
        选D  \\
        森林与二叉树的转换依据(左孩子右兄弟表示法)若森林内只有一颗树,则右指针为空;但若不止一棵树
        则右指针非空. 
        }
    }
    \item 森林$T=(T_1,T_2,\ldots,T_m)$转换为二叉树BT的过程为:若m=0,则BT为空,若$m\neq 0$,则(    ) 
    \begin{choices}[1]
        \task 将中间子树$T_{mid}(mid=(1+m)/2)$的根作为BT的根;将$(T_1,T_2,\ldots,T_{mid-1})$转换为BT的左子树;
        将$(T_{mid+1},\ldots,T_m)$转换为BT的右子树 
        \task 将子树$T_1$的根作为BT的根,将$T_1$的子树森林转换为BT的左子树;将$(T_2,T_3\ldots,T_m)$转换BT的右子树 
        \task 将子树$T_1$根作为BT的根,将$T_1$的左子森林转换为BT的左子树;右子森林转换右子树,其他类似 
        \task 将森林T的根作为BT的根,将$(T_1,\ldots,T_m)$转换为该根下的结点,得到一棵树,然后将这课树转换为二叉树 
    \end{choices}


    \answer{
        \bs {
            选B \\
            将森林的每棵树视为兄弟结点,再按照左孩子右兄弟的规则来转换.
        }
    }
    \item 设F是一个森林,B是由F转换为来的二叉树.若F中有n个非终端节点,则B中右指针域为空的结点数目是(    ) 

    \answer{
        \bs {
            n+1 \\
            二叉树B中右指针为空的结点表明该结点无无兄弟结点. \\
            其中森林中所有根结点中仅最右边的根的右指针为空,所有中间结点的孩子中,必然有且仅有一个孩子右指针为空(n个) \\
            综上有$n+1$个右指针为空
        }
    }
    \item \bl 将森林转换为对应的二叉树,若二叉树中,结点u是结点v的父结点的父结点,则原来的森林中,u和v可能具有关系是(   ) 
    \begin{enumerate}
        \item [(1)] 父子关系 
        \item [(2)] 兄弟关系
        \item [(3)] u的父结点和v的父结点是兄弟关系
    \end{enumerate}
    \begin{choices}
        \task 2 
        \task 1,2
        \task 1,3
        \task 1,2,3 
    \end{choices}

    \answer{
        \bs {
            选B \\
            这个III,老头想问的是 "在原来森林中u的父结点和v的父结点"是不是兄弟,而不是问转换后的二叉树
            "u的父结点和v的父结点"在原来的森林中是不是兄弟关系.
        }
    }
    \item \bl 已知一颗有2011个结点的树,其叶结点个数为116,则该树对应的二叉树中无右孩子的结点个数为(   )
    \begin{choices}
        \task 115
        \task 116
        \task 1895
        \task 1896
    \end{choices}

    \answer{
        \bs {
            1896 \\
            这道题和46题考察的内容一致. 每个分支结点的最右孩子必然无右指针,根结点也必然无(单棵树),故$n-n_0+1=1896$
        }
    }
    \item \bl 若森林F有15条边,25个结点,则F包含树的个数是(    ) 

    \answer{
        \bs {
            10 \\
            对于一棵树其结点与边数满足(n=e-1),对于每棵树其节点数比边数多1,而本题结点比边数多$25-15=10$棵树.
        }
    }
    \item \bl 若将一颗树T转换为对应的二叉树BT,则下列对BT的遍历中,其遍历序列与T的后根遍历序列相同的是(   ) 
    \begin{choices}
        \task 先序遍历
        \task 中序遍历
        \task 后序遍历
        \task 层序遍历
    \end{choices}

    \answer{
        \bs {
            选B \\
            对于一颗多叉树与二叉树的转换后的遍历关系有如下: \\
            先根遍历(多叉树) $\rightarrow$ 先序遍历(二叉树) \\
            后根遍历(多叉树) $\rightarrow$ 中序遍历(二叉树) \\
            多叉树没有所谓的中根遍历. 
        }
    }
    \item 在有n个叶节点的哈夫曼树中,非叶结点的总数是(   ) 
    
    \answer{
        \bs {
            $n-1$ \\
            (二叉)哈夫曼树的重要特征:仅包含度为0或者度为2的节点.又因为非空二叉树满足$n_2=n_0-1$故非叶结点
            总数为$n-1$
        }
    }
    \item 设哈夫曼编码的长度不超过4,若已对两个字符编码为1和01,则还最多可以对(   )个个字符编码 
    
    \answer{
        \bs {
            4 \\
            哈夫曼编码是前缀编码,3位编码可以是(000)此时四位编码可以是(0010,0011);同理3为编码是(001)时候,四位
            编码为(0010,0011)是不是答案就是3呢?并不是,并没有说一定要有3位编码,若只用4为编码此时可能的编码有(0000,0001,0010,0011)
            有4种编码方式. 
        }
    }
    \item 一下对于哈夫曼树的说法中,错误的是(    ) 
    \begin{choices}[1]
        \task 对应一组权值构造出来的哈夫曼树一般不是唯一的
        \task 哈夫曼树具有最小的带权路径长度
        \task 哈夫曼树中没有度为1的结点
        \task 哈夫曼树中除了度为1的节点外,还有度为2的结点和叶结点 
    \end{choices}

    \answer{
        \bs {
            选D \\
            考虑哈夫曼树的构造过程,每次选取和最小的两个结点作为叶结点.而这两个结点何者为左
            结点,何者为右结点是不确定,故哈夫曼树通常是不唯一的. 
        }
    }
    \item 若度为m的哈夫曼树中,叶结点的数目为n,则非叶结点的数目为(     ) 
    
    \answer{
        \bs {
            $\lceil(n-1)/(m-1)\rceil$ \\
            由于哈夫曼树的特性可知,m叉哈夫曼树仅有度为0和度为m的结点.设总结点数为$N=n_0+n_m$又因为
            N个结点的哈夫曼树有$N-1$条分支,则$mn_m=N-1=n_m+n_0-1$即$n_m=(n_-1)/(m-1)$
        }
    }
    \item \bl 已知字符集\underline{a,b,c,d,e,f}若各字符出现的次数分别为\underline{6,3,8,2,10,4}则对应字符集中的
    各字符的哈夫曼编码可能是(    ) 
    \begin{choices}[2]
        \task \underline{00,1011,01,1010,11,100} 
        \task \underline{00,100,110,000,0010,01}
        \task \underline{10,1011,11,0011,00,010}
        \task \underline{0011,10,11,0010,01,000}
    \end{choices}

    \answer{
        \bs {
            选A \\
            注意构建哈夫曼树,至于左右孩子谁为0谁为1是不确定.可以带入选项判断. 
        }
    }
    \item \bl 对应任意给定的含有n个字符的有限集合S,用二叉树表示S的哈夫曼编码集和定长编码集,分别得到二叉树$T_1$和$T_2$.下列叙述
    正确的是(    ) 
    \begin{choices}[1]
        \task $T_1$和$T_2$的结点数相同
        \task $T_1$的高度大于$T_2$的高度
        \task 出现频次不同的字符在$T_1$中处于不同的层
        \task 出现频次不同的字符在$T_2$中处于相同的层
    \end{choices}

    \answer{
        \bs {
            选D 
        }
    }

    \item 带权有向图G用临接矩阵存储,则$v_i$的入度等于邻接矩阵中(    )
    \begin{choices}[2]
        \task 第i行非$\infty$的元素个数
        \task 第i列非$\infty$的元素个数
        \task 第i行非$\infty$且非0的元素个数
        \task 第i列非$\infty$且非0的元素个数
    \end{choices}

    \item n个顶点的无向图的邻接表中最多有(   )个边表节点
    
    \item 假设有n个顶点,e条边的有向图用邻接表表示,则删除与某个顶点v相关的所有边的
    时间复杂度是(    ) 

    \item 对于一个有n个顶点,e条边的图采用临接表表示时,进行DFS遍历的时间复杂度是(   ),空间复杂度是
    (   );进行BFS遍历的时间复杂度是(   ),空间复杂度是(    ) 

    \item 对于一个有n个顶点,e条边的图采用临接矩阵表示时,进行DFS遍历的时间复杂度是(   ),空间复杂度是
    (   );进行BFS遍历的时间复杂度是(   ),空间复杂度是(    ) 

    \item 图的广度优先生成树的树高比深度优先生成的树高(    ) 
    \begin{choices}
        \task 小或相等
        \task 小 
        \task 大或相等 
        \task 大
    \end{choices}

    \item 一下叙述中,正确的是(   ) 
    \begin{choices}[1]
        \task 最短路径一定是简单路径
        \task Dijkstra算法不适合求有环路的带权图的最短路径
        \task Dijkstra算法不适合求任意两个顶点的最短路径 
        \task Floyd算法求两个顶点的最短路径,$path_k-1$一定是$path_k$的子集 
    \end{choices}

    \item 若一个有向图的顶点不能排成一个拓扑序列,则可以判断该有向图(    ) 
    \begin{choices}[2]
        \task 含有多个出度为0的顶点
        \task 是一个强连通图
        \task 含有多个入度为0的顶点
        \task 含有顶点数大于1的强连通分量 
    \end{choices}

    \item 下列关于图的说法中,正确的是(   ) 
    \begin{enumerate}
        \item [(1)] 有向图中顶点V的度等于其临接矩阵中第V行中1的个数
        \item [(2)] 无向图的邻接矩阵一定是对称矩阵,有向图的邻接矩阵一定是非对称矩阵
        \item [(3)] 在带权图$G$的最小生成树$G_i$中,某条边的权值可能会超过为选边的权值
        \item [(4)] 若有向无环图的拓扑序列唯一,则可以唯一确定该图 
    \end{enumerate}
    \begin{choices}
        \task 1,2,3
        \task 3,4
        \task 3
        \task 4
    \end{choices}

    \item 已知带权图为$G=(V,E)$,其中$V=\{v_1,v_2,\ldots,v_{10}\}$,边集合为$E=\{<v_1,v_2>5,
    <v_1,v_3>6,<v_2,v_5>3,<v_3,v_5>6,<v_3,v_4>3,<v_4,v_5>3,<v_4,v_7>1,<v_4,v_8>4,<v_5,v_6>4,
    <v_5,v_7>2,<v_6,v_{10}>4,<v_7,v_9>5,<v_8,v_9>2,<v_9,v_{10}>2\}$则G的关键路径长度为(   ) 

    \answer{
        
    }

    \item 下列关于关键路径的说法中,正确的是(   ) 
    \begin{enumerate}
        \item [(1)]改变网上某一关键路径上的某一关键路径,必将产生不同的关键路径
        \item [(2)]在AOE图中,关键路径上活动的时间延长多少,整个工期的时间也就随之延长多少
        \item [(3)]缩短关键路径上任意一个关键活动的持续时间可缩短关键路径长度
        \item [(4)]缩短所有关键路径上共有的任意一个关键活动的持续时间可缩短关键路径的长度
        \item [(5)]缩短多条关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度 
    \end{enumerate}
    \begin{choices}
        \task 2,5
        \task 1,2,4
        \task 2,4
        \task 1,4
    \end{choices}

    \item \bl 若用临接矩阵存储有向图,矩阵中主对角线以下的元素全为零,则关于该图拓扑序列的结论是(   )
    \begin{choices}[2]
        \task 存在,且唯一
        \task 存在,且不唯一
        \task 存在,可能唯一
        \task 无法确定是否存在
    \end{choices}

    \item \bl 对下列图所示的有向带权图,若采用Dijkstra算法求源点a到其他个顶点的最短路径,则得到的
    的第一条最短路径的目标顶点是b,第二条最短路径的目标顶点是c,后续得到的其余各最短路径的目标顶点一次是(   )
    \begin{center}
        \begin{tikzpicture}[scale=1.5,
        vertex/.style={circle, draw, minimum size=6mm, font=\small},
        edge/.style={->, thick},
        label/.style={font=\footnotesize, pos=.5, auto=center, fill=white, inner sep=1pt}
    ]

    % 顶点
    \node[vertex] (a) at (-2,-2) {a};
    \node[vertex] (b) at (-1,-1) {b};
    \node[vertex] (c) at (-1,-3) {c};
    \node[vertex] (d) at (1,-1) {d};
    \node[vertex] (e) at (1,-3) {e};
    \node[vertex] (f) at (2,-2) {f};

    % 有向边
    \draw[edge] (a) -- node[label] {2} (b);
    \draw[edge] (a) -- node[label] {5} (c);
    \draw[edge] (b) -- node[label] {1} (c);
    \draw[edge] (b) -- node[label] {3} (d);
    \draw[edge] (c) -- node[label] {3} (d);
    \draw[edge] (c) -- node[label] {1} (f);
    \draw[edge] (c) -- node[label] {4} (e);
    \draw[edge] (d) -- node[label] {1} (e);
    \draw[edge] (d) -- node[label] {4} (f);
    \draw[edge] (e) -- node[label] {1} (f);

    \end{tikzpicture}
    \end{center}
    \begin{choices}
        \task d,e,f 
        \task e,d,f 
        \task f,d,e 
        \task f,e,d
    \end{choices}


    \item \bl 使用Dijkstra算法求下图中从顶点1到其他个顶点的最短路径,依次得到的各最短路径的目标
    顶点是(   )

    \begin{center}
    \begin{tikzpicture}[scale=2.5,
    vertex/.style={circle, draw, minimum size=6mm, font=\small},
    edge/.style={->, thick},
    label/.style={font=\footnotesize, pos=.5, auto=center, fill=white, inner sep=1pt}
    ]

    % 顶点
    \node[vertex] (1) at (0,0) {1};
    \node[vertex] (2) at (1,0) {2};
    \node[vertex] (3) at (2,0) {3};
    \node[vertex] (4) at (0,-1) {4};
    \node[vertex] (5) at (1,-1) {5};
    \node[vertex] (6) at (2,-1) {6};

    % 有向边（1→5 用弧线下弯，2→4 用弧线上弯）
    \draw[edge,bend right=15] (1) to node[label,below left=-1pt] {4} (5);
    \draw[edge,bend left =15] (2) to node[label,above right=-1pt] {9} (4);

    % 其余直线边
    \draw[edge] (1) -- node[label] {5} (2);
    \draw[edge] (2) -- node[label] {2} (3);
    \draw[edge] (3) -- node[label] {6} (5);
    \draw[edge] (4) -- node[label] {2} (1);
    \draw[edge] (5) -- node[label] {6} (2);
    \draw[edge] (5) -- node[label] {7} (4);
    \draw[edge] (5) -- node[label] {5} (6);
    \draw[edge] (6) -- node[label] {2} (3);

    \end{tikzpicture}
    \end{center}

    \begin{choices}
        \task 5,2,3,4,6
        \task 5,2,3,6,4
        \task 5,2,4,3,6
        \task 5,2,6,3,4
    \end{choices}

    \item \bl 下列所示的AOE网表示一项包含8个活动的工程,活动d的最早开始时间和最迟开始时间分别是(   ) 

    \begin{center}
    \begin{tikzpicture}[scale=2,
    vertex/.style={circle, draw, minimum size=6mm, font=\small},
    edge/.style={->, thick},
    label/.style={font=\footnotesize, pos=.5, auto=center, fill=white, inner sep=1pt}
    ]

    % 顶点
    \node[vertex] (1) at (0,0) {1};
    \node[vertex] (2) at (1,0.5) {2};
    \node[vertex] (3) at (1,-0.5) {3};
    \node[vertex] (4) at (2,0.5) {4};
    \node[vertex] (5) at (2,-0.5) {5};
    \node[vertex] (6) at (3,0) {6};

    \draw[edge] (1) -- node[label] {a=3} (2);
    \draw[edge] (1) -- node[label] {c=8} (3);
    \draw[edge] (2) -- node[label] {d=7} (4);
    \draw[edge] (2) -- node[label] {e=6} (5);
    \draw[edge] (3) -- node[label] {b=4} (2);
    \draw[edge] (3) -- node[label] {f=10} (5);
    \draw[edge] (4) -- node[label] {g=6} (6);
    \draw[edge] (5) -- node[label] {h=9} (6);
    \end{tikzpicture}
    \end{center}
    \begin{choices}
        \task 3,7
        \task 12,12
        \task 12,14
        \task 15,15
    \end{choices}

    \item 由n个数据元素组成的两个表:一个递增有序,一个无序.采用顺序查找算法,对有序表从头开始查找,发现当前
    元素已不小于待查元素时,停止查找,确定查找不成功,已知查找任意元素的概率是相同的,则在两种表中成功查找(   ) 
    \begin{choices}[2]
        \task 平均时间后者小
        \task 平均时间两者相同
        \task 平均时间前者小
        \task 无法确定
    \end{choices}

    \item 在一个顺序存储的有序线性表上查找一个数据时,既可以采用折半查找,也可以采用顺序查找,但前者
    比后者的查找速度(   ) 
    \begin{choices}[2]
        \task 必然快
        \task 取决于表是递增还是递减
        \task 在大部分情况下要快
        \task 必然不快 
    \end{choices}

    \item 折半查找过程所对应的判断树是一颗(   ) 
    \begin{choices}
        \task 最小生成树
        \task 平衡二叉树
        \task 完全二叉树
        \task 满二叉树
    \end{choices}

    \item 折半查找和二叉排序树的时间性能(   ) 
    \begin{choices}
        \task 相同
        \task 有时不相同
        \task 完全不同
        \task 无法比较
    \end{choices}

    \item 对表长为n的有序表进行折半查找,其判定树的高度为(    ) 
    \begin{choices}
        \task $\lceil\log_{2}{(n+1)}\rceil$
        \task $\log_{2}{(n+1)}-1$
        \task $\lceil\log_{2}{n}\rceil$
        \task $\lfloor\log_2{n}\rfloor$ - 1
    \end{choices}

    \item 具有12个关键字的有序表中,对每个关键的查找概率相同,折半查找算法查找成功的平均查找长度是(   ),
    折半查找失败的平均查找长度是(    ) 

    \item 为提高查找效率,对有65025个元素的有序顺序表建立索引顺序结构,在最好的情况下查找到表中亦有元素最多
    需要执行(   )次关键字比较 

    \item \bl 已知一个长度为16的顺序表L,其元素按关键字有序排列,若采用折半查找法查找一个L中不存在的元素,则
    关键字的比较次数最多是(    ) 


    \item \bl 下列二叉树中，可能成为折半查找判定树（不含外部结点）的是
    \begin{center}
    \includegraphics[scale=0.35]{17-折半查找.png}
    \end{center}

    
    \item 在含有n个结点的二叉排序中查找某个关键字的结点时,最多进行(   )比较 
    \item 构建一颗具有n个节点的二叉排序树时,最理想情况下的深度为(   )
    \item 含有20个节点的平衡二叉树的最大深度为(   )
    \item 具有5层结点的AVL树至少有(   )个结点

    \item 下列关于红黑树的说法中,正确的是(   ) 
    \begin{choices}[1]
        \task 红黑树的红结点的数目最多和黑结点的数目相同
        \task 若红黑树的所有结点都是黑色的,那么它一定是一棵满二叉树
        \task 红黑树的任何一个分支结点都有两个非空孩子结点
        \task 红黑树的子树也一定是红黑树
    \end{choices}

    \item \bt 将关键字序列\underline{1,2,3,4,5,6,7}一次插入初始为空的红黑树T,则T中红结点的个数是(    ) 
    \item \bl 现有一颗无重复关键字的平衡二叉树,对其进行中序遍历得到一个降序序列,下列关于该平衡二叉树的叙述中,正确的是(  ) 
    \begin{choices}[2]
        \task 根结点的度一定是2
        \task 树中最小元素一定是叶结点
        \task 最后插入的元素一定是叶结点
        \task 树中最大元素一定是无左子树
    \end{choices}

    \item \bl 在任意一颗非空平衡二叉树$T_1$中,删除某结点v之后形成平衡二叉树$T_2$,再将v插入$T_2$形成
    平衡二叉树$T_3$下列关于$T_1,T_3$的描述中,正确的是(   )
    \begin{enumerate}
        \item [(1)] 若v是$T_1$的叶结点,则$T_1$和$T_3$可能不相同 
        \item [(2)] 若v不是$T_1$的叶结点,则$T_1$和$T_3$一定不相同
        \item [(3)] 若v不是$T_1$的叶节点,则$T_1$和$T_3$一定相同 
    \end{enumerate}
    \begin{choices}
        \task 1
        \task 2
        \task 1,2
        \task 1,3
    \end{choices}
    \item 下列关于B与B+树的描述中,不正确的是(   ) 
    \begin{choices}[2]
        \task B数和B+树都能有效的支持顺序查找
        \task B树和B+树都能有效的支持随机查找
        \task B树和B+树都是平衡的二叉树
        \task B树和B+树都可以用于文件索引结构
    \end{choices}

    \item \bl 已知一颗3阶B树,如下图所示.删除关键字78得到一颗新B树,其最右叶结点中的关键字是(   )
    \begin{center}
        \begin{forest}
        for tree={
        rectangle,           % 方框
        draw,                % 画边
        minimum size=6mm,    % 宽、高最小 6 mm
        inner sep=2pt,       % 文字与框距离
        edge=-               % 去掉箭头（默认是无箭头实线）
        }
    [45
        [
            17 35 
            [10][21][37]
        ]
        [
            55 65
            [47][60 62][78]
        ]
    ]
        \end{forest}
    \end{center}

    \item \bl 在一颗高度为2的5阶B树中,所含有的关键的个数至少是(   ) 
    \begin{choices}
        \task 5
        \task 7
        \task 8
        \task 14
    \end{choices}

    \item \bl 下列应用中,适合使用B+树的是(   ) 
    \begin{choices}[2]
        \task 编译器中的词法分析
        \task 关系数据库系统的索引
        \task 网络中的路由表的快速查找
        \task 操作系统的磁盘空闲块管理
    \end{choices}

    \item 在开放定址法中散列到同一地址而引起的堆积问题是由于(   )而引起的
    \begin{choices}[2]
        \task 同义词之间发生冲突
        \task 非同义词之间发生冲突
        \task 同义词之间或非同义词之间发生冲突 
        \task 散列表溢出 
    \end{choices}

    \item 下列关于散列冲突处理方法中,正确的是(   ) 
    \begin{enumerate}
        \item [(1)] 采用在平方探测法处理冲突时不容易产生聚集
        \item [(2)] 采用线性探测法解决冲突时,所有同义词在散列表中一定相邻
        \item [(3)] 采用链地址法处理冲突时,若限定在链首插入,则插入任意一个元素的时间是相同的 
        \item [(4)] 采用链地址法处理冲突时容易引起聚集现象
    \end{enumerate}

    \item 对包含n个元素的散列表进行查找,平均查找长度为(   ) 
    \begin{choices}
        \task 为$O(\log_{2}{n})$
        \task 为$O(1)$
        \task 不直接依赖于n
        \task 直接依赖于表长m
    \end{choices}

    \item \bl 现有长度为11且初始为空的散列表HT,散列函数$H(k)=k\%7$,用线性探测再散列法法解决冲突,将
    关键字序列\underline{87,40,30,6,11,22,98,20}依次插入HT后,HT查找失败的平均查找长度是(   )
    \begin{choices}
        \task 4
        \task 5.25
        \task 6
        \task 6.29
    \end{choices}

    \item \bl 下列因素中,影响哈希方法的平均查找长度是(   ) 
    \begin{enumerate}
        \item [(1)] 装填因子
        \item [(2)] 散列函数
        \item [(3)] 冲突解决策略
    \end{enumerate}
    \begin{choices}
        \task 1,2
        \task 1,3
        \task 2,3
        \task 1,2,3
    \end{choices}

    \item 下列关于排序的叙述中,正确的是(   ) 
    \begin{choices}[1]
        \task 稳定的排序方法优于不稳定的排序方法
        \task 对同一线性表使用不同的排序方法进行排序,得到的排序结果可能不同
        \task 排序方法都是在顺序表上实现的,在链表上无法实现排序方法
        \task 在顺序表上实现的排序方法在链表上也可以实现
    \end{choices}

    \item 对于任意7个关键字进行基于比较的排序,至少要进行()次关键字之间的比较
    \begin{choices}
        \task 13
        \task 14
        \task 15
        \task 16
    \end{choices}

    \item 用直接插入排序算法对下列4个表进行排序(从小到大),比较次数最少的是(   ) 
    \begin{choices}[2]
        \task \underline{94,32,40,90,80,46,21,69}
        \task \underline{21,32,46,40,80,69,90,94}
        \task \underline{32,40,21,46,69,94,90,80}
        \task \underline{90,69,80,46,21,32,94,40}
    \end{choices}

    \item 对序列\underline{98,36,9,0,47,23,1,8,10,7}采用希尔排序,下列序列( )是增量为4的一趟排序结果 
    \begin{choices}[2]
        \task \underline{10,7,-9,0,47,23,1,8,98,36}
        \task \underline{-9,0,36,98,1,8,23,47,7,10}
        \task \underline{36,98,-9,0,23,47,1,8,7,10}
        \task 以上都不对
    \end{choices}

    \item 若用冒泡排序算法对序列\underline{10,14,26,29,41,52}从大到小进行排序,则需要进行(  )比较 
    \begin{choices}
        \task 3
        \task 10
        \task 15
        \task 25
    \end{choices}

    \item 一组记录的关键码为\underline{46,79,56,38,40,84},采用快速排序,以第一个记录为基准,从小到大得到
    的一次划分结果为(   ) 
    \begin{choices}[2]
        \task \underline{38,40,46,56,79,84}
        \task \underline{40,38,46,79,56,84}
        \task \underline{40,38,46,56,79,84}
        \task \underline{40,38,46,84,56,79}
    \end{choices}

    \item 快速排序算法在()情况下不利于其发挥长处 
    \begin{choices}[2]
        \task 要排序的数据量太大
        \task 要排序的数据中包含多个相同的值
        \task 要排序的数据个数为奇数
        \task 要排序的数据基本有序
    \end{choices}

    \item 对下列关键字序列用到了快排进行排序,速度最快的情形是()速度最慢的是() 
    \begin{choices}[2]
        \task \underline{21,25,5,17,9,23,30}
        \task \underline{25,23,30,17,21,5,9}
        \task \underline{21,9,17,30,25,23,5}
        \task \underline{5,9,17,21,23,25,30}
    \end{choices}

    \item 对于下列4个序列,以第一个关键字为基准用快速排序算法进行排序,在第一趟过程中移动记录次数最多的是()
    \begin{choices}[2]
        \task \underline{92,96,88,42,30,35,110,100}
        \task \underline{92,96,100,110,42,35,30,88}
        \task \underline{100,96,92,35,30,110,88,42}
        \task \underline{42,30,35,92,100,96,88,110}
    \end{choices}


    \item 设线性表中每个元素有两个数据项$k_1,k_2$现对线性表按以下规则进行排序,先看数据项$k_1$,若比其值
    小的元素在前,大的元素在后,与其值相同再看$k_2$,小的元素在前,大的元素在后.满足这种要求的算法是(   ) 
    \begin{choices}[1]
        \task 先按$k_1$进行直接插入排序,在按$k_2$进行简单选择排序
        \task 先按$k_2$进行直接插入排序,在按$k_1$进行简单选择排序
        \task 先按$k_1$进行简单选择排序,在按$k_2$进行直接插入排序
        \task 先按$k_2$进行简单选择排序,在按$k_1$进行直接插入排序
    \end{choices}

    \item 若只想得到1000个元素组成的序列中第10个最小元素之前的部分排序的序列,则用()方法最快. 
    \begin{choices}
        \task 冒泡排序
        \task 快速排序
        \task 希尔排序
        \task 堆排序
    \end{choices}

    \item 在含有n个关键字的小根堆中,关键字最大的记录可能存储在(   )位置 
    \begin{choices}
        \task n/2 
        \task n/2 + 2 
        \task 1
        \task n/2 - 1
    \end{choices}

    \item 构建n个记录的初始堆,其时间复杂度为(),对n个记录进行堆排序,最坏情况下时间复杂度是()
    \begin{choices}
        \task $O(n)$
        \task $o(n^2)$
        \task $O(\log_2{n})$
        \task $O(n\log_2{n})$
    \end{choices}

    \item 对关键字\underline{23,17,72,60,25,8,68,71,52}进行堆排序,输出两个最小关键码后的剩余堆堆是()
    \begin{choices}[2]
        \task \underline{23,72,60,25,68,71,52}
        \task \underline{23,25,52,60,71,72,68}
        \task \underline{71,25,23,52,60,72,68}
        \task \underline{23,25,68,52,60,72,71}
    \end{choices}

    \item 已知小根堆为\underline{8,15,10,21,34,16,12}删除关键字8之后需要重新建堆,关键字之间的比较次数是()
    \begin{choices}
        \task 1
        \task 2
        \task 3
        \task 4
    \end{choices}

    \item 将序列\underline{6,1,5,9,8,4,7}建成大根堆时,正确的序列变化时() 
    \begin{choices}[1]
        \task 6,1,7,9,8,4,5$\rightarrow$6,9,7,1,8,4,5$\rightarrow$9,6,7,1,8,4,5$\rightarrow$9,8,7,1,6,4,5
        \task 6,9,5,1,8,4,7$\rightarrow$6,9,7,1,8,4,5$\rightarrow$9,6,7,1,8,4,5$\rightarrow$9,8,7,1,6,4,5
        \task 6,9,5,1,8,4,7$\rightarrow$9,6,5,1,8,4,7$\rightarrow$9,6,7,1,8,4,5$\rightarrow$9,8,7,1,6,4,5
        \task 6,1,7,9,8,4,5$\rightarrow$7,1,6,9,8,4,5$\rightarrow$7,9,6,1,8,4,5$\rightarrow$9,7,6,1,8,4,5$\rightarrow$9,8,6,1,7,4,5
    \end{choices}

    \item 下列关于大根堆(至少包含两个元素)的叙述中,正确的是()
    \begin{enumerate}
        \item [(1)]可以将堆视为一颗完全二叉树
        \item [(2)]可以采用顺序存储方式保存堆
        \item [(3)]可以将堆视为一棵二叉排序树
        \item [(4)]堆中的次大值一定在根的下一层
    \end{enumerate}
    \begin{choices}
        \task 1,2
        \task 2,3
        \task 1,2,4
        \task 1,3,4
    \end{choices}

    \item 若对27个元素值进行三趟多路归并排序,则选取的归并路数最少是() 
    \begin{choices}
        \task 2
        \task 3
        \task 4
        \task 5
    \end{choices}

    \item 将两个各有N个元素的有序表合并为一个有序表,最少的比较次数(),最多比较次数是() 
    \begin{choices}
        \task N 
        \task 2N-1 
        \task 2N 
        \task N-1 
    \end{choices}

    \item 若要求排序是稳定的,且关键字为实数,则在下列排序中应该选用() 
    \begin{choices}
        \task 直接插入排序
        \task 选择排序
        \task 基数排序
        \task 快速排序 
    \end{choices}

    \item 下列排序算法中属于稳定排序的是(),平均时间复杂度为$O(n\log{n})$的是(),在最好的情况下,
    时间复杂度可以达到线性的时间有() 
    \begin{choices}[4]
        \task 冒泡排序
        \task 堆排序
        \task 选择排序 
        \task 直接插入排序 
        \task 希尔排序 
        \task 归并排序 
        \task 快速排序
    \end{choices}

    \item 若序列的原始状态为\underline{1,2,3,4,5,10,6,7,8,9}要想使得排序过程中元素比较次数最少,则应该采用的是()
    \begin{choices}
        \task 插入排序 
        \task 选择排序 
        \task 希尔排序 
        \task 冒泡排序 
    \end{choices}

    \item \bl 下列排序方法中,若将顺序存储转换为链式存储,则算法时间效率会降低的是() 
    \begin{choices}[3]
        \task 插入排序 
        \task 选择排序
        \task 冒泡排序
        \task 希尔排序 
        \task 堆排序 
    \end{choices}

    \item 设有5个初始归并段,每个归并段有20个记录,采用5路平衡归并排序,若不采用败者树,使用传统的
    顺序选择出最小记录(简单选择排序)的方法,总的比较次数为();若采用败者树最小的方法,总的比较次数约为() 
    \begin{choices}
        \task 20
        \task 300
        \task 396
        \task 500
    \end{choices}

    \item 在做m路平衡归并排序过程中,为实现输入/内部归并/输出的并行处理,需要设置()个输入缓冲区和()输出
    缓冲区. 
    \begin{choices}
        \task 2
        \task m
        \task 2m-1
        \task 2m
    \end{choices}

    \item \bl 已知三叉树T中的6个叶结点的权分别是\underline{2,3,4,5,6,7},T的带权路径长度最小是() 
    \begin{choices}
        \task 27
        \task 46
        \task 54
        \task 56
    \end{choices}

    \item \bl 设外存上有120个初始归并段,进行12路归并时,为实现最佳归并,则需要补充的虚段个数是() 
    \begin{choices}
        \task 1
        \task 2
        \task 3
        \task 4
    \end{choices}



\end{enumerate}
\section{综合题}
\ifx\allfiles\undefined
\end{document}
\fi